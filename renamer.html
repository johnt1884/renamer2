<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thumbnail Generator</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #EBEBEB;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        .main-container {
            display: flex;
            height: 100%;
        }
        .sidebar {
            width: 200px;
            padding: 0;
            border-right: 1px solid #444444;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative; /* Needed for the resizer */
        }

        #sidebar-resizer {
            position: absolute;
            top: 0;
            right: -5px; /* Positioned slightly outside the border */
            width: 10px;
            height: 100%;
            cursor: col-resize;
            z-index: 100;
        }
        #sidebar-scroll-container {
            flex-grow: 1;
            overflow-y: auto;
            height: 0;
            text-align: left;
        }
        .sidebar-section h4, .sidebar-subcategory h5, #sidebar-scroll-container h4, #sidebar-scroll-container h5, #sidebar-scroll-container h6 {
            color: black;
            margin: 10px 0 5px 8px;
            cursor: pointer;
            user-select: none;
            padding: 2px 4px;
            text-align: left;
        }
        .sidebar-subcategory h5 {
            margin-left: 16px;
        }
        .sidebar-buttons {
            display: flex;
            height: 36px;
        }
        .sidebar-cog-btn {
            width: 100%;
            height: 36px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            box-sizing: border-box;
        }
        .sidebar-cog-btn:hover {
            background-color: #166fe5;
        }
        #load-directory-btn {
            flex: 1;
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 8px;
            cursor: pointer;
            box-sizing: border-box;
        }
        #load-directory-btn:hover {
            background-color: #166fe5;
        }
        .modal-content button, #last-dir-btn {
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 8px;
            cursor: pointer;
            box-sizing: border-box;
        }
        .modal-content button:hover {
            background-color: #166fe5;
        }
        #directory-picker {
            display: none;
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .top-bar {
            padding: 10px 20px 10px 0px;
            border-bottom: 1px solid #444444;
            display: flex;
            align-items: center;
            height: 36px; /* Match button height */
            box-sizing: border-box;
            background-color: #1877f2;
        }
        .bottom-bar {
            padding: 10px 10px 10px 0px;
            border-top: 1px solid #444444;
            display: flex;
            align-items: center;
            height: 36px; /* Match button height */
            box-sizing: border-box;
            background-color: #1877f2;
            color: white;
            justify-content: space-between;
        }
        .top-bar label {
            margin-right: 10px; /* Add padding between label and dropdown */
        }
        #thumbnail-container {
            flex-grow: 1;
            padding: 20px;
            position: relative;
            overflow: auto;
        }
        .thumbnail-wrapper.list-view {
            display: flex;
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
        }
        .thumbnail-wrapper.list-view .thumbnail {
            width: 128px;
            height: 72px;
            margin-right: 10px;
        }
        .thumbnail-wrapper.list-view .thumbnail-name {
            display: block;
            font-size: 14px;
            color: black;
        }
        .thumbnail {
            object-fit: cover;
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            cursor: move;
        }
        .thumbnail-placeholder {
            background-color: #e0e0e0;
            border: 2px dashed #cccccc;
            border-radius: 6px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 24px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 680px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }
        .close {
            color: #606770;
            float: right;
            font-size: 32px;
            font-weight: bold;
            line-height: 1;
        }
        .close:hover,
        .close:focus {
            color: #1c1e21;
            text-decoration: none;
            cursor: pointer;
        }
        #batch-script {
            width: 100%;
            box-sizing: border-box;
            border-radius: 6px;
            border: 1px solid #ccd0d5;
            padding: 8px;
            font-family: "Courier New", Courier, monospace;
            margin-top: 8px;
            margin-bottom: 12px;
            resize: vertical;
        }
        #selection-box {
            position: absolute;
            border: 2px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.2);
            pointer-events: none;
            display: none;
            z-index: 2147483647;
        }
        .landscape-row.selected-landscape {
            outline: 3px dashed blue;
        }
        .landscape-row.selected-landscape-rotate {
            outline: 3px dashed green;
        }
        .landscape-row.selected-delete {
            outline: 3px dashed purple;
        }
        .landscape-row.selected-edit {
            outline: 3px dashed #DAA520; /* Darker yellow */
        }
        .landscape-row.selected-play {
            outline: 3px solid cyan;
        }
        .thumbnail-wrapper {
            display: inline-block;
            vertical-align: top;
            text-align: center;
        }
        .thumbnail-name {
            font-size: 12px;
            color: black;
            background-color: #EBEBEB;
            padding: 2px;
            word-wrap: break-word;
            max-width: 256px; /* Match default thumbnail width */
            display: none; /* Hidden by default */
        }
        .thumbnail-wrapper.selected .thumbnail {
            box-shadow: 0 0 0 3px #007bff, 0 4px 8px rgba(0,0,0,0.4);
        }

        #multi-select-btn.active {
            background-color: #d93025 !important;
            color: #ffffff !important;
            border: 1px solid #ffffff;
        }

        #video-overlay {
            position: absolute;
            top: 37px; /* Height of top-bar */
            left: 200px; /* Width of sidebar */
            right: 0;
            bottom: 50%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video-player-container {
            position: relative;
            width: 80%;
            height: 80%;
        }

        #video-player {
            width: 100%;
            height: 100%;
        }

        #video-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            background: #fff;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
        }

        #video-prev-btn, #video-next-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            background: #fff;
            border: none;
            font-size: 24px;
            padding: 10px;
        }

        #video-prev-btn {
            left: 10px;
        }

        #video-next-btn {
            right: 10px;
        }

        /* Style for dropdown menus to match button height */
        select {
            height: 36px;
            padding: 0 8px 0 8px;
            padding-right: 32px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            text-align: center;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
        }

        #size-selector {
            padding: 0 8px 0 8px;
            padding-right: 32px;
        }

        select:focus {
            outline: none;
            border-color: #166fe5;
        }

        select option {
            padding: 8px 12px;
            background-color: #ffffff;
            color: #000000;
            text-align: center;
        }

        select option:nth-child(even) {
            background-color: #f2f2f2;
        }

        /* Style for top-bar buttons */
        .top-bar button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }

        .top-bar button:hover {
            background-color: #166fe5;
        }

        .top-bar button:disabled {
            background-color: #666666;
            cursor: not-allowed;
        }

        #landscape-buttons button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }

        #landscape-buttons button:hover {
            background-color: #166fe5;
        }

        #landscape-buttons button:not(:first-child) {
            border-left: none;
        }

        #landscape-buttons button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }


        /* Style for layout name input */
        #layout-name-input {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            width: 120px;
        }

        #layout-name-input:focus {
            outline: none;
            border-color: #166fe5;
        }

        #layout-name-input::placeholder {
            color: #ffffff;
            opacity: 0.7;
        }

        .dropdown {
            position: relative;
            height: 100%;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #ffffff;
            color: #000000;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
        }

        .dropdown-content a {
            color: #000000;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }

        .dropdown-content a:nth-child(even) {
            background-color: #f2f2f2;
        }

        .dropdown-content a:hover {background-color: #f1f1f1;}

        .nested-dropdown {
            position: relative;
        }

        .nested-dropdown-content {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background-color: #ffffff;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        }

        .sidebar-section button.selected-for-removal,
        #sidebar-scroll-container button.selected-for-removal {
            background-color: #d93025 !important;
            color: #ffffff !important;
            border: 1px solid #ffffff;
        }

        .disabled-btn {
            background-color: #666666 !important;
            cursor: not-allowed !important;
        }

        /* Styles for the new filename builder panel */
        .filename-builder-modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 24px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 720px; /* Wider for more complex builder */
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: fadeIn 0.3s;
            color: #000000; /* Set default text color for the modal */
        }

        #filename-preview {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-family: monospace;
            min-height: 24px;
            border: 1px solid #ddd;
            word-wrap: break-word;
            white-space: pre-wrap; /* Allow line breaks */
        }

        .filename-part-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .filename-part-row input[type="text"],
        .filename-part-row select {
            flex-grow: 1;
            margin-right: 8px;
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #ffffff;
            color: #000000;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
        }

        .filename-part-row button {
            height: 36px;
            width: 36px;
            border: 1px solid #444444;
            background-color: #f2f2f2;
            color: #000000;
            cursor: pointer;
        }

        #add-filename-part-controls {
            display: flex;
            align-items: center;
            margin-top: 15px;
        }
        
        #add-filename-part-controls button {
            height: 36px;
            width: 36px;
            margin-right: 8px;
             border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            font-size: 20px;
            cursor: pointer;
        }

         #add-filename-part-controls select {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #ffffff;
            color: #000000;
         }

        #create-filename-button-btn {
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 16px;
            cursor: pointer;
            display: block;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div id="sidebar-resizer"></div>
            <div class="sidebar-buttons">
                <div class="dropdown">
                    <button class="sidebar-cog-btn" id="cog-btn">⚙</button>
                    <div class="dropdown-content" id="cog-dropdown">
                        <div id="project-username-container" style="padding: 12px 16px;">
                            <label for="project-username-input" style="display: block; margin-bottom: 5px;">Project Username</label>
                            <input type="text" id="project-username-input" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <a href="#" id="rename-canvas-btn">Rename Canvas</a>
                        <a href="#" id="scan-for-buttons-btn">Scan for Buttons</a>
                        <a href="#" id="remove-all-buttons-btn">Remove All Buttons</a>
                        <div class="nested-dropdown" id="thumbnails-menu">
                            <a href="#">Thumbnails</a>
                            <div class="nested-dropdown-content" id="thumbnails-menu-list">
                                <a href="#" id="generate-folder-thumbnails-btn">Generate folder thumbnails</a>
                                <a href="#" id="refresh-thumbnails-btn">Refresh Thumbnails</a>
                                <a href="#" id="generate-edit-thumbnails-btn">Generate Thumbnails for Edit Mode</a>
                                <a href="#" id="generate-edit-thumbnails-new-btn">Generate Thumbnails for Edit Mode for New Files</a>
                            </div>
                        </div>
                        <div id="edit-mode-options" style="display:none;">
                            <a href="#" id="edit-mode-btn">Edit Mode: Off</a>
                            <a href="#" id="generate-edit-bat-btn">Generate Edit Bat</a>
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="num-elements-input" style="display: block; margin-bottom: 5px;">Number of Elements</label>
                            <input type="number" id="num-elements-input" min="1" value="1" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                             <a href="#" id="visible-buttons-btn">Visible Buttons</a>
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="font-size-slider" style="display: block; margin-bottom: 5px;">Button Font Size</label>
                            <input type="range" id="font-size-slider" min="8" max="24" value="14" style="width: 100%;">
                        </div>
                        <div class="nested-dropdown" id="recent-directories-dropdown">
                            <a href="#">Recent Directories</a>
                            <div class="nested-dropdown-content" id="recent-directories-list">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                        <a href="#" id="import-project-btn">Import Project</a>
                        <a href="#" id="export-project-btn">Export Project</a>
                    </div>
                </div>
                <button id="load-directory-btn">Load Directory</button>
            </div>
            <div id="sidebar-scroll-container">
                <!-- Custom buttons will be loaded here -->
            </div>
        </div>
        <div class="main-content">
            <div class="top-bar">
                <select id="size-selector">
                    <option value="list">List</option>
                    <option value="0.2">20%</option>
                    <option value="0.3">30%</option>
                    <option value="0.4">40%</option>
                    <option value="0.5">50%</option>
                    <option value="0.6">60%</option>
                    <option value="0.7">70%</option>
                    <option value="0.8">80%</option>
                    <option value="0.9">90%</option>
                    <option value="1" selected>100%</option>
                </select>
                <select id="sort-selector">
                    <option value="" disabled hidden>Sort</option>
                    <option value="name">Name</option>
                    <option value="random">Random</option>
                </select>
                <input type="text" id="layout-name-input" placeholder="Layout Name">
                <button id="save-layout-btn">Save Layout</button>
                <select id="layout-select">
                    <option value="" disabled hidden>Layout Select</option>
                </select>
                <button id="load-layout-btn">Load Layout</button>
                <button id="delete-layout-btn">Delete Layout</button>
                <button id="multi-select-btn">Multi Select</button>
                <button id="deselect-all-btn">Deselect All</button>
                <button id="hide-btn" disabled>Hide</button>
                <button id="split-btn" disabled>Split</button>
                <select id="canvas-select">
                    <option value="1">Canvas 1</option>
                </select>
                <select id="send-to-canvas-select" disabled>
                    <option value="" disabled hidden>Send to...</option>
                </select>
                <button id="close-canvas-btn" disabled>Close Canvas</button>
                <button id="play-btn" disabled>Play</button>
            </div>
            <div id="thumbnail-container">
                <div id="selection-box"></div>
                <div id="content-spacer" style="position: absolute; top: 0; left: 0; z-index: -1;"></div>
            </div>
            <div class="bottom-bar">
                <div style="display: flex;">
                    <button id="new-filename-btn" style="height: 36px; padding: 0; width: 60px; text-align: center; border: 1px solid #444444; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer;">New</button>
                    <button id="remove-btn" style="height: 36px; padding: 0 12px; border: 1px solid #444444; border-left: none; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer;">Remove</button>
                </div>
                <div id="bottom-bar-info" style="flex-grow: 1; text-align: right;"></div>
                <div id="landscape-buttons" style="display: none;">
                    <button id="deselect-row-btn">Deselect</button>
                    <button id="landscape-btn">Landscape</button>
                    <button id="landscape-rotate-btn">Landscape Rotate</button>
                    <button id="delete-btn">Delete</button>
                    <button id="edit-btn">Edit</button>
                    <button id="select-btn">Select</button>
                </div>
            </div>
        </div>
    </div>

    <div id="filename-builder-modal" class="modal">
        <div class="filename-builder-modal-content">
            <span class="close">&times;</span>
            <h2>Create New Filename Button</h2>
            <p>Define a category and add one or more elements to create a button.</p>
            
            <h4>Preview:</h4>
            <div id="filename-preview"></div>

            <div id="filename-parts-container">
                <!-- Dynamic parts will be added here -->
            </div>

            <datalist id="previous-categories-list"></datalist>
            <datalist id="previous-elements-list"></datalist>

            <div id="add-filename-part-controls">
                <button id="add-element-btn">+</button>
            </div>

            <button id="create-filename-button-btn">Add Button</button>
        </div>
    </div>

    <div id="video-overlay" style="display: none;">
        <div id="video-player-container">
            <video id="video-player" controls></video>
            <button id="video-close-btn">X</button>
            <button id="video-prev-btn">&lt;&lt;</button>
            <button id="video-next-btn">&gt;&gt;</button>
        </div>
    </div>

    <div id="script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Generate Thumbnails</h2>
            <p>The "Thumbnails" subdirectory is missing. Here is a batch script to generate them. You will need FFmpeg installed and in your system's PATH.</p>
            <textarea id="batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-script-btn">Copy to Clipboard</button>
            <a id="download-script-link" download="generate_thumbnails.bat">
                <button>Download .bat File</button>
            </a>
            <button id="reload-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>
    
    <div id="visible-buttons-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Visible Buttons</h2>
            <p>Select which buttons to display in the sidebar.</p>
            <div id="visible-buttons-list-container" style="max-height: 400px; overflow-y: auto;">
                <!-- Button visibility controls will be dynamically added here -->
            </div>
        </div>
    </div>

    <div id="edit-script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Generate Edit Thumbnails</h2>
            <p>This script will extract 10 screenshots from each video. You will need FFmpeg installed and in your system's PATH.</p>
            <textarea id="edit-batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-edit-script-btn">Copy to Clipboard</button>
            <a id="download-edit-script-link" download="generate_edit_thumbnails.bat">
                <button>Download .bat File</button>
            </a>
            <button id="reload-edit-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>

    <div id="final-landscape-script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Final Processing PowerShell Script</h2>
            <p>This script will process your selections. Right-click and "Run with PowerShell" in your main video directory.</p>
            <textarea id="final-landscape-batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-final-landscape-script-btn">Copy to Clipboard</button>
            <a id="download-final-landscape-script-link" download="process_selections.ps1">
                <button>Download .ps1 File</button>
            </a>
            <button id="reload-final-script-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>

    <script>
        // --- IndexedDB Helpers ---
        function getDb(key) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('thumbnail-tool-db', 1);
                request.onupgradeneeded = () => request.result.createObjectStore('store');
                request.onsuccess = () => {
                    const tx = request.result.transaction('store', 'readonly');
                    const store = tx.objectStore('store');
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                    tx.oncomplete = () => request.result.close();
                };
                request.onerror = () => reject(request.error);
            });
        }

        function setDb(key, value) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('thumbnail-tool-db', 1);
                request.onupgradeneeded = () => request.result.createObjectStore('store');
                request.onsuccess = () => {
                    const tx = request.result.transaction('store', 'readwrite');
                    const store = tx.objectStore('store');
                    const req = store.put(value, key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                    tx.oncomplete = () => request.result.close();
                };
                request.onerror = () => reject(request.error);
            });
        }

        // --- New LocalStorage Helpers ---
        const APP_VERSION = "2.0";

        function loadProjectData(dirName) {
            const rawData = localStorage.getItem(`projectData-${dirName}`);
            if (!rawData) {
                return {
                    version: APP_VERSION,
                    projectUsername: '',
                    numElements: 1,
                    fontSize: 14,
                    customButtonTree: [],
                    collapseState: {},
                    buttonVisibility: {},
                    canvases: null, // Keep canvas data separate for now
                    layouts: {}
                };
            }
            try {
                const data = JSON.parse(rawData);
                // Simple migration logic can be added here if data.version !== APP_VERSION
                return data;
            } catch (e) {
                console.error("Failed to parse project data, returning defaults.", e);
                return {
                    version: APP_VERSION,
                    projectUsername: '',
                    numElements: 1,
                    fontSize: 14,
                    customButtonTree: [],
                    collapseState: {},
                    buttonVisibility: {},
                    canvases: null,
                    layouts: {}
                };
            }
        }

        function saveProjectData(dirName, data) {
            data.version = APP_VERSION;
            localStorage.setItem(`projectData-${dirName}`, JSON.stringify(data));
        }

        const directoryPicker = document.getElementById('directory-picker');
        const thumbnailContainer = document.getElementById('thumbnail-container');
        const scriptModal = document.getElementById('script-modal');
        const filenameBuilderModal = document.getElementById('filename-builder-modal');
        const batchScriptTextArea = document.getElementById('batch-script');
        const copyScriptBtn = document.getElementById('copy-script-btn');
        const downloadScriptLink = document.getElementById('download-script-link');
        const reloadPageBtn = document.getElementById('reload-page-btn');
        const closeModal = document.querySelector('.close');
        const sizeSelector = document.getElementById('size-selector');
        let isLayoutFrozen = false;
        var directoryName = '';
        let zIndexCounter = 1000;
        const loadButton = document.getElementById('load-directory-btn');
        const saveLayoutBtn = document.getElementById('save-layout-btn');
        const layoutNameInput = document.getElementById('layout-name-input');
        const layoutSelect = document.getElementById('layout-select');
        const loadLayoutBtn = document.getElementById('load-layout-btn');
        const deleteLayoutBtn = document.getElementById('delete-layout-btn');
        const selectionBox = document.getElementById('selection-box');
        const contentSpacer = document.getElementById('content-spacer');
        let selectedThumbnails = new Set();
        let allVideoFiles = [];
        const playBtn = document.getElementById('play-btn');
        let scanLayouts = {};
        const splitBtn = document.getElementById('split-btn');
        const canvasSelect = document.getElementById('canvas-select');
        const multiSelectBtn = document.getElementById('multi-select-btn');
        const sendToCanvasSelect = document.getElementById('send-to-canvas-select');
        const closeCanvasBtn = document.getElementById('close-canvas-btn');
        const renameCanvasBtn = document.getElementById('rename-canvas-btn');
        const scanForButtonsBtn = document.getElementById('scan-for-buttons-btn');
        const removeAllButtonsBtn = document.getElementById('remove-all-buttons-btn');
        const deselectAllBtn = document.getElementById('deselect-all-btn');
        const hideBtn = document.getElementById('hide-btn');
        let isMultiSelectMode = false;
        const sortSelector = document.getElementById('sort-selector');
        const cogBtn = document.getElementById('cog-btn');
        const newFilenameBtn = document.getElementById('new-filename-btn');
        const removeBtn = document.getElementById('remove-btn');
        const visibleButtonsBtn = document.getElementById('visible-buttons-btn');
        const visibleButtonsModal = document.getElementById('visible-buttons-modal');
        const visibleButtonsListContainer = document.getElementById('visible-buttons-list-container');
        const thumbnailsMenu = document.getElementById('thumbnails-menu');
        const generateFolderThumbnailsBtn = document.getElementById('generate-folder-thumbnails-btn');
        const refreshThumbnailsBtn = document.getElementById('refresh-thumbnails-btn');
        const generateEditThumbnailsBtn = document.getElementById('generate-edit-thumbnails-btn');
        const generateEditThumbnailsNewBtn = document.getElementById('generate-edit-thumbnails-new-btn');
        const editScriptModal = document.getElementById('edit-script-modal');
        const recentDirectoriesDropdown = document.getElementById('recent-directories-dropdown');
        
        let buttonsForRemoval = new Set();
        let filenameParts = [];
        const filenamePreview = document.getElementById('filename-preview');
        const filenamePartsContainer = document.getElementById('filename-parts-container');
        const addPartBtn = document.getElementById('add-part-btn');
        const createFilenameButtonBtn = document.getElementById('create-filename-button-btn');

        var canvases = new Map();
        let activeCanvasId = 1;
        let allThumbnails = [];
        let currentDirHandle;
        let landscapeSelectionMode = ''; // 'landscape' or 'landscape-rotate'
        let preEditModeCanvasMap = new Map();
        const landscapeSelections = new Set();
        const landscapeRotateSelections = new Set();
        const deleteSelections = new Set();
        const editSelections = new Set();
        const playSelections = new Set();

        function updateRemoveButtonState() {
            if (buttonsForRemoval.size === 0) {
                removeBtn.classList.add('disabled-btn');
                removeBtn.disabled = true;
            } else {
                removeBtn.classList.remove('disabled-btn');
                removeBtn.disabled = false;
            }
        }

        function getNextCanvasId() {
            let i = 1;
            while (canvases.has(i)) {
                i++;
            }
            return i;
        }

        function renderCanvas(canvasId) {
            activeCanvasId = canvasId;
            thumbnailContainer.innerHTML = ''; // Clear container
            thumbnailContainer.appendChild(selectionBox);
            thumbnailContainer.appendChild(contentSpacer);

            const canvas = canvases.get(canvasId);
            if (canvas) {
                document.title = canvas.name;
                hideBtn.textContent = canvas.name === 'Hidden' ? 'Unhide' : 'Hide';
                canvas.thumbnails.forEach(thumb => {
                    thumbnailContainer.appendChild(thumb);
                });
            }

            const currentCanvas = canvases.get(activeCanvasId);
            closeCanvasBtn.disabled = !(currentCanvas && currentCanvas.thumbnails.length === 0 && canvases.size > 1 && currentCanvas.name !== 'Renamed');
            
            populateCanvasDropdown();
            layoutThumbnailsInGrid();
        }

        function populateCanvasDropdown() {
            canvasSelect.innerHTML = '';
            sendToCanvasSelect.innerHTML = '<option value="" disabled selected hidden>Send to...</option>';
            for (const canvas of canvases.values()) {
                const option = document.createElement('option');
                option.value = canvas.id;
                option.textContent = canvas.name;
                canvasSelect.appendChild(option.cloneNode(true));
                if (canvas.id !== activeCanvasId) {
                    sendToCanvasSelect.appendChild(option);
                }
            }
            canvasSelect.value = activeCanvasId;
        }

        const videoOverlay = document.getElementById('video-overlay');
        const videoPlayer = document.getElementById('video-player');
        const videoCloseBtn = document.getElementById('video-close-btn');
        const videoPrevBtn = document.getElementById('video-prev-btn');
        const videoNextBtn = document.getElementById('video-next-btn');
        let playlist = [];
        let currentPlaylistIndex = -1;
        let currentVideoUrl = null;

        function loadVideo(index) {
            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
            }
            
            currentPlaylistIndex = index;
            const thumbWrapper = playlist[index];
            const fileName = thumbWrapper.dataset.fileName || thumbWrapper.querySelector('.thumbnail').dataset.fileName;
            if (!fileName) {
                console.error("Could not find a filename for the selected thumbnail.", thumbWrapper);
                return; // or handle the error appropriately
            }
            const thumbName = fileName.substring(0, fileName.lastIndexOf('.'));

            // Find the video file by matching the base name, ignoring the extension
            const videoFile = allVideoFiles.find(f => f.name.substring(0, f.name.lastIndexOf('.')) === thumbName);
            
            if (videoFile) {
                currentVideoUrl = URL.createObjectURL(videoFile);
                videoPlayer.src = currentVideoUrl;
                videoPlayer.play();
            }

            videoPrevBtn.style.display = index > 0 ? 'block' : 'none';
            videoNextBtn.style.display = index < playlist.length - 1 ? 'block' : 'none';
        }

        function updatePlayButtonState() {
            const editModeBtn = document.getElementById('edit-mode-btn');
            const inEditMode = editModeBtn && editModeBtn.textContent.includes('On');
            
            if (inEditMode) {
                playBtn.disabled = playSelections.size === 0;
                splitBtn.disabled = true;
                sendToCanvasSelect.disabled = true;
                hideBtn.disabled = true;
            } else {
                const numSelected = selectedThumbnails.size;
                playBtn.disabled = numSelected === 0;
                splitBtn.disabled = numSelected === 0;
                sendToCanvasSelect.disabled = numSelected === 0;
                hideBtn.disabled = numSelected === 0;
            }
        }

        function updateContentSpacer() {
            const thumbnails = document.querySelectorAll('.thumbnail');
            if (thumbnails.length === 0) {
                contentSpacer.style.width = '0px';
                contentSpacer.style.height = '0px';
                return;
            }

            let maxRight = 0;
            let maxBottom = 0;

            thumbnails.forEach(thumb => {
                const right = thumb.offsetLeft + thumb.offsetWidth;
                const bottom = thumb.offsetTop + thumb.offsetHeight;
                if (right > maxRight) maxRight = right;
                if (bottom > maxBottom) maxBottom = bottom;
            });

            // Add a small buffer
            contentSpacer.style.width = (maxRight + 20) + 'px';
            contentSpacer.style.height = (maxBottom + 20) + 'px';
        }

        async function init() {
            const projectData = loadProjectData(directoryName);
            const savedSize = projectData.thumbnailSize || '1';
            sizeSelector.value = savedSize;
            await loadRecentDirectories();
            updateRemoveButtonState();

            recentDirectoriesDropdown.addEventListener('click', (event) => {
                event.stopPropagation();
                const list = document.getElementById('recent-directories-list');
                list.style.display = list.style.display === 'block' ? 'none' : 'block';
            });

            if (!directoryName) {
                directoryName = 'default'; // For testing purposes
            }

            const numElementsInput = document.getElementById('num-elements-input');
            numElementsInput.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.numElements = numElementsInput.value;
                saveProjectData(directoryName, projectData);
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
            });

            const fontSizeSlider = document.getElementById('font-size-slider');
            fontSizeSlider.addEventListener('input', () => {
                const buttons = document.querySelectorAll('#sidebar-scroll-container button');
                buttons.forEach(button => {
                    button.style.fontSize = `${fontSizeSlider.value}px`;
                    adjustButtonFontSize(button);
                });
            });
            fontSizeSlider.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.fontSize = fontSizeSlider.value;
                saveProjectData(directoryName, projectData);
            });

            const dirHandle = await getDb('lastDirectory');
            if (dirHandle && typeof dirHandle.queryPermission === 'function') {
                try {
                    const hasPermission = await dirHandle.queryPermission({ mode: 'read' }) === 'granted' ||
                                          await dirHandle.requestPermission({ mode: 'read' }) === 'granted';
                    if (hasPermission) {
                        await processDirectory(dirHandle);
                    } else {
                         console.error('Permission to access the last directory was denied.');
                         await setDb('lastDirectory', null);
                    }
                } catch (err) {
                    console.error('Could not auto-load directory:', err);
                    await setDb('lastDirectory', null);
                    await loadRecentDirectories(); 
                }
            } else if (dirHandle) {
                console.warn('Last directory handle from IndexedDB was invalid. Clearing.');
                await setDb('lastDirectory', null);
            }
        }

        loadButton.addEventListener('click', async () => {
            try {
                const dirHandle = await window.showDirectoryPicker();
                await processDirectory(dirHandle);
            } catch (err) {
                if (err.name !== 'AbortError') console.error('Failed to open directory:', err);
            }
        });

        cogBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const dropdown = document.getElementById('cog-dropdown');
            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        });

        // Prevent clicks inside the dropdown from closing it
        document.getElementById('cog-dropdown').addEventListener('click', (event) => {
            event.stopPropagation();
        });

        thumbnailsMenu.addEventListener('click', (event) => {
            event.stopPropagation();
            const list = document.getElementById('thumbnails-menu-list');
            list.style.display = list.style.display === 'block' ? 'none' : 'block';
        });

        generateEditThumbnailsBtn.addEventListener('click', () => {
            if (allVideoFiles.length === 0) {
                alert('No video files loaded. Please load a directory first.');
                return;
            }
            generateEditBatchScript(allVideoFiles);
            editScriptModal.style.display = 'block';
        });

        editScriptModal.querySelector('.close').addEventListener('click', () => {
            editScriptModal.style.display = 'none';
        });

        document.getElementById('copy-edit-script-btn').addEventListener('click', () => {
            const scriptTextArea = document.getElementById('edit-batch-script');
            scriptTextArea.select();
            navigator.clipboard.writeText(scriptTextArea.value).then(() => {
                alert('Script copied to clipboard!');
                document.getElementById('reload-edit-page-btn').style.display = 'inline-block';
            });
        });

        document.getElementById('download-edit-script-link').addEventListener('click', () => {
            document.getElementById('reload-edit-page-btn').style.display = 'inline-block';
        });

        document.getElementById('reload-edit-page-btn').addEventListener('click', () => {
            location.reload();
        });

        document.getElementById('landscape-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'landscape' ? '' : 'landscape';
            updateSelectionModeButtons();
        });

        document.getElementById('landscape-rotate-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'landscape-rotate' ? '' : 'landscape-rotate';
            updateSelectionModeButtons();
        });

        document.getElementById('delete-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'delete' ? '' : 'delete';
            updateSelectionModeButtons();
        });

        document.getElementById('edit-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'edit' ? '' : 'edit';
            updateSelectionModeButtons();
        });

        document.getElementById('select-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'play' ? '' : 'play';
            updateSelectionModeButtons();
        });

        document.getElementById('deselect-row-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to deselect all rows?')) {
                landscapeSelections.clear();
                landscapeRotateSelections.clear();
                deleteSelections.clear();
                editSelections.clear();
                playSelections.clear();

                document.querySelectorAll('.landscape-row').forEach(row => {
                    row.classList.remove('selected-landscape', 'selected-landscape-rotate', 'selected-delete', 'selected-edit', 'selected-play');
                });
            }
        });

        function updateSelectionModeButtons() {
            const blue = '#1877f2';
            const red = '#d93025';
            document.getElementById('landscape-btn').style.backgroundColor = landscapeSelectionMode === 'landscape' ? red : blue;
            document.getElementById('landscape-rotate-btn').style.backgroundColor = landscapeSelectionMode === 'landscape-rotate' ? red : blue;
            document.getElementById('delete-btn').style.backgroundColor = landscapeSelectionMode === 'delete' ? red : blue;
            document.getElementById('edit-btn').style.backgroundColor = landscapeSelectionMode === 'edit' ? red : blue;
            document.getElementById('select-btn').style.backgroundColor = landscapeSelectionMode === 'play' ? red : blue;
        }


        const projectUsernameInput = document.getElementById('project-username-input');
        projectUsernameInput.addEventListener('change', () => {
            if (directoryName) {
                const projectData = loadProjectData(directoryName);
                projectData.projectUsername = projectUsernameInput.value;
                saveProjectData(directoryName, projectData);
            }
            updateFilenamePreview();
        });

        document.getElementById('project-username-container').addEventListener('click', (event) => {
            event.stopPropagation();
        });

        window.addEventListener('click', (event) => {
            const dropdown = document.getElementById('cog-dropdown');
            // If the click is outside the cog button AND outside the dropdown content
            if (!event.target.matches('.sidebar-cog-btn') && !dropdown.contains(event.target)) {
                if (dropdown.style.display === 'block') {
                    dropdown.style.display = 'none';
                    document.getElementById('recent-directories-list').style.display = 'none';
                }
            }
        });

        renameCanvasBtn.addEventListener('click', () => {
            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas) {
                if (currentCanvas.name === 'Renamed') {
                    alert('The "Renamed" canvas cannot be renamed.');
                    return;
                }
                const newName = prompt('Enter new name for the canvas:', currentCanvas.name);
                if (newName && newName.trim() !== '') {
                    currentCanvas.name = newName.trim();
                    document.title = newName.trim();
                    populateCanvasDropdown();
                }
            }
            document.getElementById('cog-dropdown').style.display = 'none';
        });

        removeAllButtonsBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to remove all custom buttons for this directory?')) {
                const projectData = loadProjectData(directoryName);
                projectData.customButtonTree = [];
                saveProjectData(directoryName, projectData);
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                alert('All custom buttons have been removed.');
            }
            document.getElementById('cog-dropdown').style.display = 'none';
        });

        function insertButtonIntoTree(tree, path, buttonData) {
            let currentLevel = tree;
            let node = null;

            for (let i = 0; i < path.length; i++) {
                const name = path[i];
                const isButton = i === path.length - 1;

                node = currentLevel.find(item => item.name === name && item.type === (isButton ? 'button' : 'category'));

                if (!node) {
                    node = {
                        name: name,
                        type: isButton ? 'button' : 'category',
                    };
                    if (isButton) {
                        Object.assign(node, { id: buttonData.id || Date.now() + Math.random(), ...buttonData });
                    } else {
                        node.children = [];
                    }
                    currentLevel.push(node);
                } else if (isButton) {
                    // If a button with the same path already exists, it's a duplicate.
                    return false; 
                }
                
                if (!isButton) {
                    currentLevel = node.children;
                }
            }
            return true; // Indicates a new button was successfully added
        }

        scanForButtonsBtn.addEventListener('click', async () => {
            let username = projectUsernameInput.value.trim();
            if (!username) {
                username = prompt('Please enter a Project Username to scan for matching filenames:');
                if (username) {
                    projectUsernameInput.value = username;
                    projectUsernameInput.dispatchEvent(new Event('change'));
                } else {
                    alert('Scan cancelled. A Project Username is required.');
                    return;
                }
            }

            const projectData = loadProjectData(directoryName);
            let customButtonTree = projectData.customButtonTree;
            let newButtonsCreated = 0;

            // Regex explained:
            // ^\\[${username}\\]_  - Matches "[username]_" at the start of the string.
            // ([^(]+)             - Captures the Category. Matches any character except '('. This is more flexible than \w+.
            // (.*)                 - Captures the rest of the string, which contains the elements.
            const regex = new RegExp(`^\\[${username}\\]_([^(]+)(.*)`);

            for (const file of allVideoFiles) {
                const match = file.name.match(regex);
                if (!match) continue;

                const category = match[1].trim();
                let rawElementsText = match[2] || '';
                
                // Clean up raw elements string: remove file extension and trailing number like (1)
                rawElementsText = rawElementsText.substring(0, rawElementsText.lastIndexOf('.')).trim();
                rawElementsText = rawElementsText.replace(/\s*\(\d+\)$/, '').trim();

                // Extract all parenthesized elements, e.g., "(Coat)" "(Black 1)"
                const elementsWithParens = rawElementsText.match(/\(([^)]+)\)/g) || [];
                
                if (elementsWithParens.length === 0) {
                    // This handles filenames like "[user]_Misc.mp4" or "[user]_Misc (1).mp4"
                    // A special "+1" button is created for simple renaming.
                    const path = [category, '+1'];
                    const buttonData = {
                        fullButtonText: '',
                        specialType: 'plusOne'
                    };
                    if (insertButtonIntoTree(customButtonTree, path, buttonData)) {
                        newButtonsCreated++;
                    }
                } else {
                    // This handles hierarchical names like "[user]_Misc (Coat) (Black 1).mp4"
                    // 1. Remove parentheses to get clean element names: ["Coat", "Black 1"]
                    const cleanElements = elementsWithParens.map(p => p.slice(1, -1));
                    
                    // 2. The full path for the tree structure: ["Misc", "Coat", "Black 1"]
                    const path = [category, ...cleanElements];
                    
                    // 3. Store the original text with parentheses for other features like highlighting
                    const buttonData = {
                        fullButtonText: elementsWithParens.join(' ')
                    };
                    
                    // 4. Insert into the tree, checking for duplicates.
                    if (insertButtonIntoTree(customButtonTree, path, buttonData)) {
                        newButtonsCreated++;
                    }
                }
            }

            if (newButtonsCreated > 0) {
                projectData.customButtonTree = customButtonTree;
                saveProjectData(directoryName, projectData);
                await loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                alert(`${newButtonsCreated} new button(s) created successfully!`);
            } else {
                alert('No new buttons were found. They may already exist or not match the current Project Username.');
            }
            
            document.getElementById('cog-dropdown').style.display = 'none';
        });


        sortSelector.addEventListener('change', (e) => {
            const value = e.target.value;
            if (value) {
                sortThumbnails(value);
                e.target.value = ''; // Reset to placeholder
            }
        });

        saveLayoutBtn.addEventListener('click', saveLayout);
        loadLayoutBtn.addEventListener('click', loadLayout);
        multiSelectBtn.addEventListener('click', () => {
            isMultiSelectMode = !isMultiSelectMode;
            multiSelectBtn.classList.toggle('active', isMultiSelectMode);
        });

        deselectAllBtn.addEventListener('click', () => {
            selectedThumbnails.forEach(thumb => thumb.classList.remove('selected'));
            selectedThumbnails.clear();
            updatePlayButtonState();
        });

        hideBtn.addEventListener('click', () => {
            if (hideBtn.textContent === 'Hide') {
                let hiddenCanvas = Array.from(canvases.values()).find(c => c.name === 'Hidden');
                if (!hiddenCanvas) {
                    const newCanvasId = getNextCanvasId();
                    hiddenCanvas = { id: newCanvasId, name: 'Hidden', thumbnails: [] };
                    canvases.set(newCanvasId, hiddenCanvas);
                }

                selectedThumbnails.forEach(thumb => {
                    thumb.dataset.previousCanvasId = activeCanvasId;
                });
                
                sendThumbnailsToCanvas(hiddenCanvas.id);
            } else { // Unhide
                const thumbnailsToUnhide = new Map();
                selectedThumbnails.forEach(thumb => {
                    const targetCanvasId = parseInt(thumb.dataset.previousCanvasId) || 1; // Default to canvas 1 if unset
                    if (!thumbnailsToUnhide.has(targetCanvasId)) {
                        thumbnailsToUnhide.set(targetCanvasId, []);
                    }
                    thumbnailsToUnhide.get(targetCanvasId).push(thumb);
                });

                const currentCanvas = canvases.get(activeCanvasId);
                thumbnailsToUnhide.forEach((thumbs, targetId) => {
                    const targetCanvas = canvases.get(targetId);
                    if (targetCanvas) {
                        thumbs.forEach(thumb => {
                            currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                            targetCanvas.thumbnails.push(thumb);
                            thumb.classList.remove('selected');
                        });
                    }
                });

                selectedThumbnails.clear();
                renderCanvas(activeCanvasId);
                updatePlayButtonState();
            }
        });

        deleteLayoutBtn.addEventListener('click', deleteLayout);
        splitBtn.addEventListener('click', () => {
            const newCanvasId = getNextCanvasId();
            const newCanvas = { id: newCanvasId, name: `Canvas ${newCanvasId}`, thumbnails: [] };
            canvases.set(newCanvasId, newCanvas);

            const currentCanvas = canvases.get(activeCanvasId);
            selectedThumbnails.forEach(thumb => {
                currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                newCanvas.thumbnails.push(thumb); // Positions are preserved
                thumb.classList.remove('selected');
            });

            selectedThumbnails.clear();
            updatePlayButtonState();
            
            populateCanvasDropdown();
            canvasSelect.value = newCanvasId;
            renderCanvas(newCanvasId);
        });
        canvasSelect.addEventListener('change', (e) => {
            renderCanvas(parseInt(e.target.value));
        });

        sendToCanvasSelect.addEventListener('change', (e) => {
            const targetCanvasId = parseInt(e.target.value);
            if (!targetCanvasId) return;
            sendThumbnailsToCanvas(targetCanvasId);
            e.target.value = ''; // Reset dropdown
        });

        closeCanvasBtn.addEventListener('click', () => {
            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas && currentCanvas.thumbnails.length === 0 && canvases.size > 1) {
                canvases.delete(activeCanvasId);
                const newActiveCanvasId = canvases.keys().next().value;
                populateCanvasDropdown();
                canvasSelect.value = newActiveCanvasId;
                renderCanvas(newActiveCanvasId);
            }
        });

        function sendThumbnailsToCanvas(targetCanvasId, clearSelection = true) {
            const targetCanvas = canvases.get(targetCanvasId);
            if (!targetCanvas) return;

            const currentCanvas = canvases.get(activeCanvasId);

            selectedThumbnails.forEach(thumb => {
                currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                targetCanvas.thumbnails.push(thumb);
                if(clearSelection) {
                    thumb.classList.remove('selected');
                }
            });

            if (clearSelection) {
                selectedThumbnails.clear();
            }
            renderCanvas(activeCanvasId); // Re-render the current canvas to show the items have moved
            updatePlayButtonState();
        }

        playBtn.addEventListener('click', () => {
            const editModeBtn = document.getElementById('edit-mode-btn');
            const inEditMode = editModeBtn && editModeBtn.textContent.includes('On');

            if (inEditMode) {
                if (playSelections.size === 0) return;
                playlist = Array.from(playSelections).map(videoName => {
                    const videoFile = allVideoFiles.find(f => f.name.startsWith(videoName));
                    if (videoFile) {
                        // Create a mock wrapper that loadVideo can use
                        return { dataset: { fileName: videoFile.name.replace(/\.[^/.]+$/, ".jpg") } };
                    }
                    return null;
                }).filter(Boolean);
            } else {
                playlist = Array.from(selectedThumbnails);
            }

            if (playlist.length > 0) {
                videoOverlay.style.display = 'flex';
                loadVideo(0);
            }
        });
        videoCloseBtn.addEventListener('click', () => {
            videoOverlay.style.display = 'none';
            videoPlayer.pause();
            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
                currentVideoUrl = null;
            }
        });
        videoPrevBtn.addEventListener('click', () => {
            if (currentPlaylistIndex > 0) {
                loadVideo(currentPlaylistIndex - 1);
            }
        });
        videoNextBtn.addEventListener('click', () => {
            if (currentPlaylistIndex < playlist.length - 1) {
                loadVideo(currentPlaylistIndex + 1);
            }
        });

        thumbnailContainer.addEventListener('mousedown', startSelection);

        closeModal.addEventListener('click', () => scriptModal.style.display = 'none');
        copyScriptBtn.addEventListener('click', copyScriptToClipboard);
        downloadScriptLink.addEventListener('click', downloadBatchFile);
        sizeSelector.addEventListener('change', (event) => {
            const newSize = event.target.value;
            const projectData = loadProjectData(directoryName);
            projectData.thumbnailSize = newSize;
            saveProjectData(directoryName, projectData);
            const editModeBtn = document.getElementById('edit-mode-btn');
            if (editModeBtn && editModeBtn.textContent.includes('On')) {
                layoutLandscapeThumbnails();
            } else {
                if (newSize === 'list') {
                    layoutThumbnailsInList();
                } else {
                    layoutThumbnailsInGrid();
                }
            }
        });

        function layoutThumbnailsInList() {
            isLayoutFrozen = false;
            thumbnailContainer.querySelectorAll('.thumbnail-wrapper').forEach(wrapper => {
                wrapper.style.position = 'relative';
                wrapper.style.left = '0px';
                wrapper.style.top = '0px';
                wrapper.classList.add('list-view');
            });
            updateContentSpacer();
        }

        function layoutThumbnailsInGrid() {
            thumbnailContainer.querySelectorAll('.thumbnail-wrapper').forEach(wrapper => {
                wrapper.classList.remove('list-view');
            });
            if (isLayoutFrozen) {
                const scale = parseFloat(sizeSelector.value);
                thumbnailContainer.querySelectorAll('.thumbnail-wrapper').forEach(wrapper => {
                    const thumb = wrapper.querySelector('.thumbnail');
                    const nameDiv = wrapper.querySelector('.thumbnail-name');
                    const originalWidth = thumb.dataset.originalWidth;
                    if (originalWidth) {
                        const scaledWidth = originalWidth * scale;
                        thumb.style.width = scaledWidth + 'px';
                        thumb.style.height = 'auto';
                        nameDiv.style.maxWidth = scaledWidth + 'px';
                    }
                });
                updateContentSpacer();
                return;
            }

            const scale = parseFloat(sizeSelector.value);
            const containerWidth = thumbnailContainer.clientWidth;
            let xOffset = 20;
            let yOffset = 20;
            let maxRowHeight = 0;

            const wrappers = thumbnailContainer.querySelectorAll('.thumbnail-wrapper');

            wrappers.forEach(wrapper => {
                const thumb = wrapper.querySelector('.thumbnail');
                const nameDiv = wrapper.querySelector('.thumbnail-name');
                
                // Temporarily make the name visible to get its height for layout calculation
                const originalDisplay = nameDiv.style.display;
                nameDiv.style.display = 'block';

                const originalWidth = parseFloat(thumb.dataset.originalWidth);
                const originalHeight = parseFloat(thumb.dataset.originalHeight);
                
                const scaledWidth = originalWidth * scale;
                const scaledHeight = originalHeight * scale;

                nameDiv.style.maxWidth = scaledWidth + 'px';
                const nameHeight = nameDiv.offsetHeight;
                
                // Restore the original display property
                nameDiv.style.display = originalDisplay;

                const wrapperHeight = scaledHeight + nameHeight + 4;

                if (xOffset + scaledWidth + 20 > containerWidth && xOffset > 20) {
                    xOffset = 20;
                    yOffset += maxRowHeight + 20;
                    maxRowHeight = 0;
                }
                
                wrapper.style.position = 'absolute';
                wrapper.style.left = xOffset + 'px';
                wrapper.style.top = yOffset + 'px';
                thumb.style.width = scaledWidth + 'px';
                thumb.style.height = scaledHeight + 'px';

                if (wrapperHeight > maxRowHeight) {
                    maxRowHeight = wrapperHeight;
                }
                
                xOffset += scaledWidth + 20;
            });

            updateContentSpacer();
        }

        async function processDirectory(dirHandle) {
            // --- Clear previous state ---
            thumbnailContainer.innerHTML = ''; // Clear thumbnails
            document.getElementById('sidebar-scroll-container').innerHTML = ''; // Clear buttons
            canvases.clear();
            allThumbnails = [];
            isLayoutFrozen = false;
            document.getElementById('edit-mode-options').style.display = 'none';


            currentDirHandle = dirHandle;
            await setDb('lastDirectory', dirHandle);
            
            let recentDirs = await getDb('recentDirectories') || [];
            const existingIndex = recentDirs.findIndex(dir => dir.name === dirHandle.name);
            if (existingIndex > -1) {
                recentDirs.splice(existingIndex, 1);
            }
            recentDirs.unshift({name: dirHandle.name, handle: dirHandle});
            if (recentDirs.length > 5) {
                recentDirs = recentDirs.slice(0, 5);
            }
            await setDb('recentDirectories', recentDirs);
            await loadRecentDirectories();

            directoryName = dirHandle.name;
            document.title = directoryName; // Update page title
            const projectData = loadProjectData(directoryName);

            projectUsernameInput.value = projectData.projectUsername || '';
            document.getElementById('num-elements-input').value = projectData.numElements || 1;
            document.getElementById('font-size-slider').value = projectData.fontSize || 14;

            loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);

            try {
                let hasEditThumbnails = false;
            let hasLandscapeVideos = false;
            let hasLandscapeRotateVideos = false;
            let hasEditVideos = false;

            try {
                await dirHandle.getDirectoryHandle('Edit Thumbnails');
                hasEditThumbnails = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }

            try {
                await dirHandle.getDirectoryHandle('Landscape');
                hasLandscapeVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }
            
            try {
                await dirHandle.getDirectoryHandle('Landscape Rotate');
                hasLandscapeRotateVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }
            
            try {
                await dirHandle.getDirectoryHandle('Edit');
                hasEditVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }


            if (hasEditThumbnails) {
                const editModeOptions = document.getElementById('edit-mode-options');
                const editModeBtn = document.getElementById('edit-mode-btn');
                const generateBatBtn = document.getElementById('generate-edit-bat-btn');

                editModeOptions.style.display = 'block';
                
                // Reset state for the new directory
                editModeBtn.textContent = 'Edit Mode Off';
                generateBatBtn.style.display = 'none';
                document.getElementById('landscape-buttons').style.display = 'none';
                
                // --- Attach listeners only once ---
                if (!editModeBtn.dataset.listenerAttached) {
                    editModeBtn.dataset.listenerAttached = 'true';
                    generateBatBtn.dataset.listenerAttached = 'true';

                    editModeBtn.addEventListener('click', () => {
                        const listOption = sizeSelector.querySelector('option[value="list"]');
                        if (editModeBtn.textContent.includes('Off')) {
                            // Before entering edit mode, save the current canvas for each thumbnail
                            preEditModeCanvasMap.clear();
                            for (const [canvasId, canvas] of canvases.entries()) {
                                canvas.thumbnails.forEach(thumbWrapper => {
                                    preEditModeCanvasMap.set(thumbWrapper.dataset.fileName, canvasId);
                                });
                            }
                            const projectData = loadProjectData(directoryName);
                            projectData.preEditModeCanvasMap = Object.fromEntries(preEditModeCanvasMap);
                            saveProjectData(directoryName, projectData);


                            renderEditMode();
                            generateBatBtn.style.display = 'block';
                            editModeBtn.textContent = 'Edit Mode On';
                            if (sizeSelector.value === 'list') {
                                sizeSelector.value = '1';
                                layoutThumbnailsInGrid();
                            }
                            listOption.disabled = true;
                        } else {
                            document.getElementById('landscape-buttons').style.display = 'none';
                            generateBatBtn.style.display = 'none';
                            editModeBtn.textContent = 'Edit Mode Off';
                            listOption.disabled = false;
                            isLayoutFrozen = false; 

                            // Force-reset all thumbnail positions before re-rendering
                            const currentCanvas = canvases.get(activeCanvasId);
                            if (currentCanvas) {
                                currentCanvas.thumbnails.forEach(thumb => {
                                    thumb.style.position = '';
                                    thumb.style.left = '';
                                    thumb.style.top = '';
                                });
                            }

                            renderCanvas(activeCanvasId);
                        }
                    });

                    generateBatBtn.addEventListener('click', () => {
                        generateFinalBatchScript();
                        document.getElementById('final-landscape-script-modal').style.display = 'block';
                    });
                }
            }

            isLayoutFrozen = false;
            selectedThumbnails.clear();
            updatePlayButtonState();
            
            allVideoFiles = [];
            let thumbnailFiles = [];
            let hasThumbnailsSubdir = false;

            async function recursivelyFindThumbnails(dirHandle, pathPrefix = '') {
                const thumbnailsDirHandle = await dirHandle.getDirectoryHandle('Thumbnails');
                for await (const entry of thumbnailsDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.match(/\.(jpe?g|png|gif|webp)$/i)) {
                        thumbnailFiles.push(await entry.getFile());
                    }
                }
            }

            scanLayouts = {}; // Reset scan layouts
            try {
                const scanDirHandle = await dirHandle.getDirectoryHandle('scan');
                for await (const entry of scanDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.json')) {
                        const file = await entry.getFile();
                        const text = await file.text();
                        try {
                            const layoutName = entry.name.replace('.json', '');
                            scanLayouts[layoutName] = JSON.parse(text);
                        } catch (e) {
                            console.error(`Error parsing ${entry.name}:`, e);
                        }
                    }
                }
            } catch (e) {
                // scan directory doesn't exist, which is fine.
            }

            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/\.(mp4|avi|mov|mkv)$/i)) {
                    allVideoFiles.push(await entry.getFile());
                }
            }

            try {
                // Find thumbnails in the root and other key directories
                await recursivelyFindThumbnails(dirHandle);
                hasThumbnailsSubdir = true;

                for (const subDir of ['Landscape', 'Landscape Rotate', 'Edit']) {
                    try {
                        const subDirHandle = await dirHandle.getDirectoryHandle(subDir);
                        await recursivelyFindThumbnails(subDirHandle, subDir);
                    } catch (e) {
                        // Subdirectory doesn't exist, which is fine.
                    }
                }
            } catch (e) {
                hasThumbnailsSubdir = false;
            }
            
            if (hasThumbnailsSubdir) {
                const savedCanvasData = projectData.canvases;

                allThumbnails = [];
                canvases.clear();
                
                const imageLoadPromises = thumbnailFiles.map(file => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            img.dataset.originalWidth = img.width;
                            img.dataset.originalHeight = img.height;
                            resolve(img);
                        };
                        img.onerror = reject;
                        img.classList.add('thumbnail');
                        img.draggable = false;
                        img.dataset.fileName = file.name;
                        img.src = URL.createObjectURL(file);
                    });
                });

                Promise.all(imageLoadPromises).then(async loadedImages => {
                    allThumbnails = loadedImages;
                    
                    try {
                        if (!savedCanvasData || !Array.isArray(savedCanvasData.canvases)) throw new Error("No valid saved data");

                        canvases = new Map(savedCanvasData.canvases.map(c => [c.id, { ...c, thumbnails: [] }]));
                        activeCanvasId = savedCanvasData.activeCanvasId;

                        const thumbMap = new Map(allThumbnails.map(t => [t.dataset.fileName, t]));

                        savedCanvasData.canvases.forEach(savedCanvas => {
                            const canvas = canvases.get(savedCanvas.id);
                             if (!canvas) return; // Skip if a canvas from save data doesn't exist
                            savedCanvas.thumbnails.forEach(savedThumb => {
                                const thumb = thumbMap.get(savedThumb.fileName);
                                if (thumb) {
                                    canvas.thumbnails.push(thumb);
                                    thumb.style.position = 'absolute';
                                    thumb.style.left = savedThumb.left;
                                    thumb.style.top = savedThumb.top;
                                     if (savedThumb.previousCanvasId) {
                                        thumb.dataset.previousCanvasId = savedThumb.previousCanvasId;
                                     }
                                    isLayoutFrozen = true;
                                }
                            });
                        });
                         // Verify that the active canvas actually exists, otherwise reset it.
                        if (!canvases.has(activeCanvasId)) {
                            activeCanvasId = canvases.keys().next().value || 1;
                        }

                    } catch (err) {
                        console.warn("Could not restore canvas from saved data. Deleting invalid data and loading fresh.", err);
                        projectData.canvases = null; // Clear bad data
                        saveProjectData(directoryName, projectData);
                        canvases.clear();
                        canvases.set(1, { id: 1, name: 'Canvas 1', thumbnails: [...allThumbnails] });
                        activeCanvasId = 1;
                        isLayoutFrozen = false;
                    }

                    let renamedCanvas = Array.from(canvases.values()).find(c => c.name === 'Renamed');
                    if (!renamedCanvas) {
                        const renamedCanvasId = getNextCanvasId();
                        canvases.set(renamedCanvasId, { id: renamedCanvasId, name: 'Renamed', thumbnails: [] });
                    }

                    // --- Auto-organize processed thumbnails ---
                    if (projectData.preEditModeCanvasMap && (hasLandscapeVideos || hasLandscapeRotateVideos || hasEditVideos)) {
                        const organizeProcessedThumbnails = async () => {
                            const preEditMap = new Map(Object.entries(projectData.preEditModeCanvasMap));
                            const processedDirs = [];
                            if (hasLandscapeVideos) processedDirs.push('Landscape');
                            if (hasLandscapeRotateVideos) processedDirs.push('Landscape Rotate');
                            if (hasEditVideos) processedDirs.push('Edit');

                            const allProcessedFiles = new Set();

                            for (const dirName of processedDirs) {
                                try {
                                    const dirHandle = await currentDirHandle.getDirectoryHandle(dirName);
                                    for await (const entry of dirHandle.values()) {
                                        if (entry.kind === 'file') {
                                            allProcessedFiles.add(entry.name.substring(0, entry.name.lastIndexOf('.')));
                                        }
                                    }
                                } catch (e) {
                                    console.warn(`Could not read processed directory ${dirName}:`, e);
                                }
                            }

                            // Create a temporary holding array for thumbnails to be moved
                            const thumbnailsToMove = [];
                            
                            // Go through all canvases and pull out any thumbnails that were processed
                            for (const sourceCanvas of canvases.values()) {
                                sourceCanvas.thumbnails = sourceCanvas.thumbnails.filter(thumb => {
                                    const baseName = thumb.dataset.fileName.substring(0, thumb.dataset.fileName.lastIndexOf('.'));
                                    if (allProcessedFiles.has(baseName)) {
                                        thumbnailsToMove.push(thumb);
                                        return false; // Remove from current canvas
                                    }
                                    return true; // Keep in current canvas
                                });
                            }

                            // Now, distribute the collected thumbnails back to their original canvases
                            thumbnailsToMove.forEach(thumb => {
                                const originalCanvasId = preEditMap.get(thumb.dataset.fileName);
                                const targetCanvas = canvases.get(originalCanvasId);
                                if (targetCanvas) {
                                     if (!targetCanvas.thumbnails.some(t => t.dataset.fileName === thumb.dataset.fileName)) {
                                        targetCanvas.thumbnails.push(thumb);
                                     }
                                } else {
                                    // Fallback: if the original canvas is gone, put it in the first canvas
                                    canvases.get(1)?.thumbnails.push(thumb);
                                }
                            });

                            // Clean up the map from localStorage after using it
                            delete projectData.preEditModeCanvasMap;
                            saveProjectData(directoryName, projectData);
                        };

                        await organizeProcessedThumbnails();
                    }

                    allThumbnails.forEach(img => {
                        // Create a wrapper for the image and its name
                        const wrapper = document.createElement('div');
                        wrapper.classList.add('thumbnail-wrapper');
                        wrapper.dataset.fileName = img.dataset.fileName;
                        wrapper.appendChild(img);

                        const nameDiv = document.createElement('div');
                        nameDiv.classList.add('thumbnail-name');
                        nameDiv.textContent = img.dataset.fileName;
                        nameDiv.dataset.originalFilename = img.dataset.fileName;
                        wrapper.appendChild(nameDiv);

                        // Replace the img with the wrapper in the canvases map
                        for (const canvas of canvases.values()) {
                            const index = canvas.thumbnails.indexOf(img);
                            if (index > -1) {
                                canvas.thumbnails[index] = wrapper;
                                break;
                            }
                        }

                        makeDraggable(wrapper);
                        
                        nameDiv.addEventListener('dblclick', () => {
                            nameDiv.contentEditable = true;
                            nameDiv.focus();
                        });

                        nameDiv.addEventListener('blur', () => {
                            nameDiv.contentEditable = false;
                            // Update the image's data attribute with the new name
                            const newName = nameDiv.textContent;
                            img.dataset.fileName = newName;
                            wrapper.dataset.fileName = newName;
                        });


                    });
                    
                    populateCanvasDropdown();
                    renderCanvas(activeCanvasId);
                });

            } else if (allVideoFiles.length > 0) {
                generateBatchScript(allVideoFiles, directoryName);
                scriptModal.style.display = 'block';
            }
            } catch (err) {
                console.error("A critical error occurred while processing the directory:", err);
                alert("An unexpected error occurred while trying to read the directory contents. Please try loading the directory again.");
            } finally {
                populateLayoutsDropdown();
            }
        }

        async function loadRecentDirectories() {
            const recentDirs = await getDb('recentDirectories') || [];
            const list = document.getElementById('recent-directories-list');
            list.innerHTML = '';

            if (recentDirs.length > 0) {
                for (const dir of recentDirs) {
                    const a = document.createElement('a');
                    a.href = '#';
                    a.textContent = dir.name;
                    a.title = dir.name;
                    a.addEventListener('click', async (e) => {
                        e.preventDefault();
                        // --- Validate handle before use ---
                        if (!dir.handle || typeof dir.handle.queryPermission !== 'function') {
                            alert('This directory reference is stale. Please re-select it using "Load Directory".');
                            await removeDirectory(dir.name);
                            return;
                        }

                        try {
                            const hasPermission = await dir.handle.queryPermission({ mode: 'read' }) === 'granted' ||
                                                  await dir.handle.requestPermission({ mode: 'read' }) === 'granted';
                            if (hasPermission) {
                                await processDirectory(dir.handle);
                                document.getElementById('cog-dropdown').style.display = 'none'; // Close menu after loading
                            }
                        } catch(e) {
                            alert('Could not access directory. It may have been moved, deleted, or permissions were denied.');
                            await removeDirectory(dir.name);
                        }
                    });
                    list.appendChild(a);
                }
            } else {
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = 'No recent directories';
                a.style.pointerEvents = 'none';
                list.appendChild(a);
            }
        }

        async function removeDirectory(dirName) {
            let recentDirs = await getDb('recentDirectories') || [];
            recentDirs = recentDirs.filter(d => d.name !== dirName);
            await setDb('recentDirectories', recentDirs);
            await loadRecentDirectories();
        }

        async function renderEditMode() {
            thumbnailContainer.innerHTML = ''; // Clear container for a clean slate
            document.getElementById('landscape-buttons').style.display = 'flex'; // Ensure buttons are visible

            const editDirHandle = await currentDirHandle.getDirectoryHandle('Edit Thumbnails');
            let landscapeFiles = [];
            for await (const entry of editDirHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/\.(jpe?g|png|gif|webp)$/i)) {
                    landscapeFiles.push(await entry.getFile());
                }
            }

            const groupedFiles = landscapeFiles.reduce((acc, file) => {
                const videoName = file.name.substring(0, file.name.lastIndexOf('_'));
                if (!acc[videoName]) {
                    acc[videoName] = [];
                }
                acc[videoName].push(file);
                return acc;
            }, {});

            const videoNames = Object.keys(groupedFiles).sort();
            const allPromises = [];

            for (const videoName of videoNames) {
                const files = groupedFiles[videoName];
                files.sort((a, b) => {
                    const aNum = parseInt(a.name.substring(a.name.lastIndexOf('_') + 1));
                    const bNum = parseInt(b.name.substring(b.name.lastIndexOf('_') + 1));
                    return aNum - bNum;
                });

                const rowDiv = document.createElement('div');
                rowDiv.classList.add('landscape-row');
                rowDiv.dataset.videoName = videoName;
                thumbnailContainer.appendChild(rowDiv);

                rowDiv.addEventListener('click', () => {
                    const selections = {
                        'landscape': landscapeSelections,
                        'landscape-rotate': landscapeRotateSelections,
                        'delete': deleteSelections,
                        'edit': editSelections,
                        'play': playSelections
                    };

                    if (!landscapeSelectionMode) {
                        alert('Please select a mode from the bottom bar first.');
                        return;
                    }

                    // Toggle selection for the current mode
                    if (selections[landscapeSelectionMode].has(videoName)) {
                        selections[landscapeSelectionMode].delete(videoName);
                    } else {
                        selections[landscapeSelectionMode].add(videoName);
                        // Ensure mutual exclusivity
                        for (const mode in selections) {
                            if (mode !== landscapeSelectionMode) {
                                selections[mode].delete(videoName);
                            }
                        }
                    }

                    // Update UI classes
                    rowDiv.classList.toggle('selected-landscape', landscapeSelections.has(videoName));
                    rowDiv.classList.toggle('selected-landscape-rotate', landscapeRotateSelections.has(videoName));
                    rowDiv.classList.toggle('selected-delete', deleteSelections.has(videoName));
                    rowDiv.classList.toggle('selected-edit', editSelections.has(videoName));
                    rowDiv.classList.toggle('selected-play', playSelections.has(videoName));
                    updatePlayButtonState();
                });

                 // Re-apply selection classes on initial render
                if (landscapeSelections.has(videoName)) rowDiv.classList.add('selected-landscape');
                if (landscapeRotateSelections.has(videoName)) rowDiv.classList.add('selected-landscape-rotate');
                if (deleteSelections.has(videoName)) rowDiv.classList.add('selected-delete');
                if (editSelections.has(videoName)) rowDiv.classList.add('selected-edit');
                if (playSelections.has(videoName)) rowDiv.classList.add('selected-play');

                const imageLoadPromises = files.map(file => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            img.classList.add('thumbnail');
                            img.dataset.fileName = file.name;
                            img.dataset.originalWidth = img.width;
                            img.dataset.originalHeight = img.height;
                            rowDiv.appendChild(img);
                            resolve(img);
                        };
                        img.onerror = reject;
                        img.src = URL.createObjectURL(file);
                    });
                });
                allPromises.push(Promise.all(imageLoadPromises));
            }

            await Promise.all(allPromises);
            layoutLandscapeThumbnails(); // Position and size after all images are loaded
        }

        function layoutLandscapeThumbnails() {
            const scale = parseFloat(sizeSelector.value);
            let yOffset = 20;
            const rows = document.querySelectorAll('.landscape-row');

            rows.forEach(row => {
                row.style.position = 'absolute';
                row.style.top = yOffset + 'px';
                let xOffset = 20;
                let maxRowHeight = 0;
                let totalRowWidth = 0;
                const thumbnails = row.querySelectorAll('.thumbnail');
                
                thumbnails.forEach((thumb, index) => {
                    const originalWidth = parseFloat(thumb.dataset.originalWidth);
                    const originalHeight = parseFloat(thumb.dataset.originalHeight);
                    
                    const scaledWidth = originalWidth * scale;
                    const scaledHeight = originalHeight * scale;

                    thumb.style.position = 'absolute';
                    thumb.style.width = scaledWidth + 'px';
                    thumb.style.height = scaledHeight + 'px';
                    thumb.style.left = xOffset + 'px';
                    thumb.style.top = '0px'; // Position relative to the row

                    xOffset += scaledWidth + 20;
                    if (scaledHeight > maxRowHeight) {
                        maxRowHeight = scaledHeight;
                    }
                });

                if (thumbnails.length > 0) {
                    totalRowWidth = xOffset;
                    row.style.width = totalRowWidth + 'px';
                    row.style.height = maxRowHeight + 'px';
                    yOffset += maxRowHeight + 20;
                }
            });
             updateContentSpacer();
        }

        function generateEditBatchScript(videoFiles) {
            const scriptLines = [
                '@echo off',
                'setlocal enabledelayedexpansion',
                'cd /d "%~dp0"',
                'echo Creating Edit Thumbnails directory...',
                'if not exist "Edit Thumbnails" mkdir "Edit Thumbnails"',
                'echo Generating edit thumbnails and updating tracking file...',
                '> processed_edit_mode_videos.txt (',
                ...videoFiles.map(file => `    echo ${file.name}`),
                ')',
                '',
                ...videoFiles.flatMap(file => {
                    const fileName = file.name;
                    const baseName = fileName.substring(0, fileName.lastIndexOf('.'));
                    return [
                        '',
                        `echo Processing "${fileName}"...`,
                        `for /f "delims=" %%a in ('ffprobe -v error -show_entries format^=duration -of default^=noprint_wrappers^=1:nokey^=1 "${fileName}"') do (`,
                        '    set "duration_str=%%a"',
                        ')',
                        'for /f "delims=." %%a in ("!duration_str!") do set "duration_int=%%a"',
                        'if !duration_int! equ 0 set "duration_int=10"', // Avoid division by zero for very short videos
                        'set /a "interval = !duration_int! / 10"',
                        'if !interval! equ 0 set "interval=1"', // Ensure at least 1s interval for very short videos
                        'for /l %%i in (1, 1, 10) do (',
                        '    set /a "timestamp = (%%i - 1) * !interval!"',
                        `    echo   - Generating thumbnail %%i for "${fileName}" at !timestamp!s...`,
                        `    ffmpeg -ss !timestamp! -i "${fileName}" -vframes 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" -y "Edit Thumbnails\\${baseName}_%%i.jpg" >nul 2>&1 || echo Failed to generate thumbnail %%i for ${fileName}`,
                        ')'
                    ];
                }),
                'echo.',
                'echo Thumbnail generation complete.',
                'pause'
            ];
            const script = scriptLines.join('\r\n');
            document.getElementById('edit-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-edit-script-link').href = URL.createObjectURL(blob);
        }

        window.onload = init;

        function generateFinalBatchScript() {
            const scriptLines = [
                '# PowerShell Script to process video selections',
                'Write-Host "Creating output directories..."',
                'if (-not (Test-Path -LiteralPath "Landscape")) { New-Item -ItemType Directory -Path "Landscape" }',
                'if (-not (Test-Path -LiteralPath "Landscape\\Thumbnails")) { New-Item -ItemType Directory -Path "Landscape\\Thumbnails" }',
                'if (-not (Test-Path -LiteralPath "Landscape Rotate")) { New-Item -ItemType Directory -Path "Landscape Rotate" }',
                'if (-not (Test-Path -LiteralPath "Landscape Rotate\\Thumbnails")) { New-Item -ItemType Directory -Path "Landscape Rotate\\Thumbnails" }',
                'if (-not (Test-Path -LiteralPath "Edit")) { New-Item -ItemType Directory -Path "Edit" }',
                'if (-not (Test-Path -LiteralPath "Edit\\Thumbnails")) { New-Item -ItemType Directory -Path "Edit\\Thumbnails" }',
                ''
            ];

            const escapeString = (str) => `'${str.replace(/'/g, "''")}'`;

            const processRenamingAndThumbnails = (videoName, action, destination = '') => {
                const wrapper = Array.from(document.querySelectorAll('.thumbnail-wrapper')).find(w => {
                    const nameDiv = w.querySelector('.thumbnail-name');
                    return nameDiv && nameDiv.dataset.originalFilename.startsWith(videoName);
                });
                
                let originalVideoFile = allVideoFiles.find(f => f.name.startsWith(videoName));
                if (!originalVideoFile) return;

                let currentVideoName = originalVideoFile.name;
                const originalThumbName = originalVideoFile.name.replace(/\.[^/.]+$/, ".jpg");

                if (wrapper) {
                    const nameDiv = wrapper.querySelector('.thumbnail-name');
                    const img = wrapper.querySelector('.thumbnail');
                    const originalFilenameAttr = nameDiv.dataset.originalFilename;
                    const currentFilenameAttr = img.dataset.fileName;

                    if (originalFilenameAttr !== currentFilenameAttr) {
                        const newVideoName = currentFilenameAttr.replace(/\.jpg$/, '.mp4');
                        scriptLines.push(`Rename-Item -LiteralPath ${escapeString(currentVideoName)} -NewName ${escapeString(newVideoName)}`);
                        currentVideoName = newVideoName;
                    }
                }
                
                const currentThumbName = currentVideoName.replace(/\.[^/.]+$/, ".jpg");

                switch (action) {
                    case 'move':
                        scriptLines.push(`Move-Item -LiteralPath ${escapeString(currentVideoName)} -Destination ${escapeString(destination)}`);
                        scriptLines.push(`if (Test-Path -LiteralPath "Thumbnails\\${originalThumbName}") { Move-Item -LiteralPath "Thumbnails\\${originalThumbName}" -Destination "${destination}\\Thumbnails\\${currentThumbName}" }`);
                        break;
                    case 'rotate':
                        scriptLines.push(`ffmpeg -i ${escapeString(currentVideoName)} -vf "transpose=1" ${escapeString(destination + '\\' + currentVideoName)}`);
                        scriptLines.push(`Remove-Item -LiteralPath ${escapeString(currentVideoName)}`); // Sends to Recycle Bin
                        scriptLines.push(`if (Test-Path -LiteralPath "Thumbnails\\${originalThumbName}") { Move-Item -LiteralPath "Thumbnails\\${originalThumbName}" -Destination "${destination}\\Thumbnails\\${currentThumbName}" }`);
                        break;
                    case 'delete':
                        scriptLines.push(`Remove-Item -LiteralPath ${escapeString(currentVideoName)}`); // Sends to Recycle Bin
                        scriptLines.push(`if (Test-Path -LiteralPath "Thumbnails\\${originalThumbName}") { Remove-Item -LiteralPath "Thumbnails\\${originalThumbName}" }`);
                        break;
                }
            };

            if (landscapeSelections.size > 0) {
                scriptLines.push('Write-Host "Moving landscape files..."');
                landscapeSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'move', 'Landscape'));
                scriptLines.push('');
            }

            if (landscapeRotateSelections.size > 0) {
                scriptLines.push('Write-Host "Processing landscape rotate files..."');
                landscapeRotateSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'move', 'Landscape Rotate'));
                scriptLines.push('');
            }

            if (deleteSelections.size > 0) {
                scriptLines.push('Write-Host "Deleting selected files (to Recycle Bin)..."');
                deleteSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'delete'));
                scriptLines.push('');
            }

            if (editSelections.size > 0) {
                scriptLines.push('Write-Host "Moving files to Edit folder..."');
                editSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'move', 'Edit'));
                scriptLines.push('');
            }
            
            scriptLines.push('Write-Host "Cleaning up..."');
            scriptLines.push('if (Test-Path -LiteralPath "Edit Thumbnails") {');
            scriptLines.push('    Remove-Item -Recurse -Force -LiteralPath "Edit Thumbnails"');
            scriptLines.push('}');
            scriptLines.push('');
            
            scriptLines.push('Write-Host "Processing complete."');
            scriptLines.push('Read-Host -Prompt "Press Enter to exit"');

            const script = scriptLines.join('\r\n');
            document.getElementById('final-landscape-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-final-landscape-script-link').href = URL.createObjectURL(blob);
        }
        
        window.onload = init;

        document.getElementById('final-landscape-script-modal').querySelector('.close').addEventListener('click', () => {
            document.getElementById('final-landscape-script-modal').style.display = 'none';
        });
        document.getElementById('copy-final-landscape-script-btn').addEventListener('click', () => {
            const scriptTextArea = document.getElementById('final-landscape-batch-script');
            scriptTextArea.select();
            navigator.clipboard.writeText(scriptTextArea.value).then(() => {
                alert('Script copied to clipboard!');
                document.getElementById('reload-final-script-page-btn').style.display = 'inline-block';
            });
        });

        document.getElementById('download-final-landscape-script-link').addEventListener('click', () => {
            document.getElementById('reload-final-script-page-btn').style.display = 'inline-block';
        });

        document.getElementById('reload-final-script-page-btn').addEventListener('click', () => {
            location.reload();
        });

        function generateBatchScript(videoFiles, dirName) {
            const scriptLines = [
                '@echo off',
                `cd /d "%~dp0"`,
                'echo Creating Thumbnails directory...',
                'if not exist "Thumbnails" mkdir Thumbnails',
                'echo Generating thumbnails...',
                ...videoFiles.map(file => {
                    const fileName = file.name;
                    const thumbnailName = fileName.substring(0, fileName.lastIndexOf('.')) + '.jpg';
                    return `ffmpeg -y -i "${fileName}" -ss 00:00:02.000 -frames:v 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" "Thumbnails\\${thumbnailName}"`;
                }),
                'echo.',
                'echo Thumbnail generation complete.',
                'pause'
            ];
            const script = scriptLines.join('\r\n');
            batchScriptTextArea.value = script;

            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
        }

        function copyScriptToClipboard() {
            batchScriptTextArea.select();
            navigator.clipboard.writeText(batchScriptTextArea.value).then(() => {
                alert('Script copied to clipboard! Paste it into a file named "generate_thumbnails.bat" in your video folder and run it.');
                reloadPageBtn.style.display = 'inline-block';
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        function downloadBatchFile() {
            alert('Once downloaded, move the ".bat" file into your video folder and double-click it to run.');
            reloadPageBtn.style.display = 'inline-block';
        }

        reloadPageBtn.addEventListener('click', () => {
            location.reload();
        });
        
        function initializeFilenameBuilder() {
            filenamePartsContainer.innerHTML = '';
            // Start with a category and one element
            filenameParts = [{ type: 'category', value: '' }, { type: 'element', value: '' }];
            renderFilenameParts();
            updateFilenamePreview();
            populatePreviousElements();
            populatePreviousCategories();
        }

        function renderFilenameParts() {
            filenamePartsContainer.innerHTML = '';
            filenameParts.forEach((part, index) => {
                const row = document.createElement('div');
                row.className = 'filename-part-row';

                const input = document.createElement('input');
                input.type = 'text';
                input.value = part.value;

                if (part.type === 'category') {
                    input.placeholder = 'Category';
                    input.setAttribute('list', 'previous-categories-list');
                } else {
                    input.placeholder = `Element ${index}`;
                    input.setAttribute('list', 'previous-elements-list');
                }

                input.addEventListener('input', () => {
                    part.value = input.value;
                    updateFilenamePreview();
                });

                row.appendChild(input);

                if (index > 0) { // Can't remove the 'Category'
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '-';
                    removeBtn.onclick = () => removeFilenamePart(index);
                    row.appendChild(removeBtn);
                }
                filenamePartsContainer.appendChild(row);
            });
        }

        function updateFilenamePreview() {
            const username = projectUsernameInput.value || 'username';
            const category = filenameParts[0]?.value.trim() || 'Category';
            
            const elements = filenameParts.slice(1)
                .map(p => p.value.trim())
                .filter(p => p);

            // Build a representative filename string for the preview
            const elementsString = elements.map(e => `(${e})`).join(' ');
            filenamePreview.textContent = `[${username}]_${category} ${elementsString} (1).mp4`;

            // Also show the final button text and structure
            if (elements.length > 0) {
                const buttonName = elements[elements.length - 1];
                let structure = category;
                if (elements.length > 1) {
                    structure += ` -> ${elements.slice(0, -1).join(' -> ')}`;
                }
                filenamePreview.textContent += `\nButton: "${buttonName}" under "${structure}"`;
            }
        }

        function addFilenamePart(value = '') {
            filenameParts.push({ type: 'element', value });
            renderFilenameParts();
            updateFilenamePreview();
        }

        function removeFilenamePart(index) {
            if (filenameParts.length > 2) { // Always keep at least one category and one element
                filenameParts.splice(index, 1);
                renderFilenameParts();
                updateFilenamePreview();
            }
        }

        function getPreviousElements() {
            const projectData = loadProjectData(directoryName);
            return projectData.previousFilenameElements || [];
        }

        function populatePreviousElements() {
            const values = getPreviousElements();
            const datalist = document.getElementById('previous-elements-list');
            datalist.innerHTML = '';
            values.forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                datalist.appendChild(option);
            });
        }

        function getPreviousCategories() {
            const projectData = loadProjectData(directoryName);
            return projectData.previousFilenameCategories || [];
        }

        function populatePreviousCategories() {
            const categories = getPreviousCategories();
            const datalist = document.getElementById('previous-categories-list');
            datalist.innerHTML = '';
            categories.forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                datalist.appendChild(option);
            });
        }

        document.getElementById('add-element-btn').addEventListener('click', () => addFilenamePart());

        createFilenameButtonBtn.addEventListener('click', () => {
            const category = filenameParts[0]?.value.trim();
            if (!category) {
                alert('A "Category" is required to create a button.');
                return;
            }

            const elements = filenameParts.slice(1).map(p => p.value.trim()).filter(p => p);
            if (elements.length === 0) {
                alert('At least one "Element" is required to create a button.');
                return;
            }
            
            // --- Save values to localStorage for future suggestions ---
            const projectData = loadProjectData(directoryName);
            projectData.previousFilenameElements = projectData.previousFilenameElements || [];
            elements.forEach(el => {
                if (el && !projectData.previousFilenameElements.includes(el)) {
                    projectData.previousFilenameElements.push(el);
                }
            });

            projectData.previousFilenameCategories = projectData.previousFilenameCategories || [];
            if (category && !projectData.previousFilenameCategories.includes(category)) {
                projectData.previousFilenameCategories.push(category);
            }

            // --- Construct button data and save to the main tree ---
            let customButtonTree = projectData.customButtonTree;
            
            const path = [category, ...elements];
            const buttonData = {
                fullButtonText: elements.map(p => `(${p})`).join(' ')
            };

            if (insertButtonIntoTree(customButtonTree, path, buttonData)) {
                projectData.customButtonTree = customButtonTree;
                saveProjectData(directoryName, projectData);
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                filenameBuilderModal.style.display = 'none';
                populatePreviousElements(); // Refresh datalists for next time
                populatePreviousCategories();
            } else {
                alert('A button with this exact name and category structure already exists.');
            }
        });

        async function loadCustomButtons(customButtonTree, collapseState, buttonVisibility) {
            if (!directoryName) {
                return;
            }
            const scrollContainer = document.getElementById('sidebar-scroll-container');
            scrollContainer.innerHTML = '';
            const numElements = parseInt(document.getElementById('num-elements-input').value, 10);

            const createCollapseClickHandler = (key) => (event) => {
                event.stopPropagation();
                const projectData = loadProjectData(directoryName);
                projectData.collapseState[key] = !projectData.collapseState[key];
                saveProjectData(directoryName, projectData);
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
            };

            function renderTree(nodes, parentContainer, level, parentPath) {
                if (!Array.isArray(nodes)) return;

                // Sort all nodes alphabetically. Special case for '+1' button to always be first.
                nodes.sort((a, b) => {
                    if (a.name === '+1') return -1;
                    if (b.name === '+1') return 1;
                    return a.name.localeCompare(b.name);
                });

                nodes.forEach(node => {
                    const currentPath = [...parentPath, node.name];
                    const nodeKey = `node_${currentPath.join('_')}`;

                    if (node.type === 'category' && level < numElements) {
                        const isCollapsed = collapseState[nodeKey] || false;
                        const header = document.createElement(`h${4 + level}`);
                        header.textContent = currentPath.join('-');
                        header.style.marginLeft = `${level * 8}px`;
                        header.style.cursor = 'pointer';
                        header.onclick = createCollapseClickHandler(nodeKey);
                        parentContainer.appendChild(header);

                        if (!isCollapsed && Array.isArray(node.children)) {
                            renderTree(node.children, parentContainer, level + 1, currentPath);
                        }
                    } else {
                        function createButtonsFromSubtree(startingNode, basePath, textParts) {
                            if (startingNode.type === 'button') {
                                if (buttonVisibility[startingNode.id] === false) return;
                                
                                const combinedName = [...textParts, startingNode.name].join(' ');
                                const finalButtonName = startingNode.specialType === 'plusOne' ? '+1' : combinedName;
                                
                                parentContainer.appendChild(createSidebarButton({ ...startingNode, name: finalButtonName }, basePath));

                            } else if (startingNode.type === 'category' && Array.isArray(startingNode.children)) {
                                const newTextParts = [...textParts, startingNode.name];
                                startingNode.children.forEach(child => {
                                    createButtonsFromSubtree(child, basePath, newTextParts);
                                });
                            }
                        }
                        // By passing an empty array `[]` as the initial textParts, we prevent the
                        // duplication bug where the starting node's name was added twice. The
                        // recursive function is responsible for building the entire name string.
                        createButtonsFromSubtree(node, currentPath.slice(0, numElements), []);
                    }
                });
            }

            renderTree(customButtonTree, scrollContainer, 0, []);
        }

    function populateVisibleButtonsModal() {
        visibleButtonsListContainer.innerHTML = '';
        const projectData = loadProjectData(directoryName);
        let customButtonTree = projectData.customButtonTree;
        const buttonVisibility = projectData.buttonVisibility;
        const numElements = parseInt(document.getElementById('num-elements-input').value, 10);

        // We'll use a modified render function to build the checklist
        function renderVisibilityChecklist(nodes, parentContainer, level, parentPath = []) {
            if (!Array.isArray(nodes)) return;

            // Use the same sorting as the main render function
            nodes.sort((a, b) => {
                if (a.name === '+1') return -1;
                if (b.name === '+1') return 1;
                if (a.type === 'category' && b.type !== 'category') return -1;
                if (a.type !== 'category' && b.type === 'category') return 1;
                return a.name.localeCompare(b.name);
            });

            nodes.forEach(node => {
                const currentPath = [...parentPath, node.name];
                if (node.type === 'category' && level <= numElements) {
                    const header = document.createElement(`h${4 + level}`);
                    header.textContent = currentPath.join('-');
                    header.style.marginLeft = `${level * 8}px`;
                    header.style.color = 'black';
                    parentContainer.appendChild(header);
                    
                    const childrenContainer = document.createElement('div');
                    renderVisibilityChecklist(node.children, childrenContainer, level + 1);
                    parentContainer.appendChild(childrenContainer);

                } else {
                     function createCheckboxesFromSubtree(startingNode, textParts) {
                        if (startingNode.type === 'button') {
                            const allTextParts = [...textParts, startingNode.name];
                            const buttonName = startingNode.specialType === 'plusOne' 
                                ? '+1'
                                : allTextParts.filter(p => p !== '+1').join(' ');
                            
                            const div = document.createElement('div');
                            div.style.marginLeft = `${(numElements + 1) * 8}px`;
                            div.style.display = 'flex';
                            div.style.alignItems = 'center';

                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.id = `vis-check-${startingNode.id}`;
                            checkbox.checked = buttonVisibility[startingNode.id] !== false; // Default to visible
                            
                            checkbox.onchange = () => {
                                projectData.buttonVisibility[startingNode.id] = checkbox.checked;
                                saveProjectData(directoryName, projectData);
                                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                            };

                            const label = document.createElement('label');
                            label.htmlFor = checkbox.id;
                            label.textContent = buttonName;
                            label.style.color = 'black';
                            label.style.marginLeft = '4px';

                            div.appendChild(checkbox);
                            div.appendChild(label);
                            parentContainer.appendChild(div);

                        } else if (startingNode.type === 'category') {
                            const newTextParts = [...textParts, startingNode.name];
                            if(Array.isArray(startingNode.children)) {
                                startingNode.children.forEach(child => createCheckboxesFromSubtree(child, newTextParts));
                            }
                        }
                    }
                    createCheckboxesFromSubtree(node, []);
                }
            });
        }

        renderVisibilityChecklist(customButtonTree, visibleButtonsListContainer, 0, []);
    }

    visibleButtonsBtn.addEventListener('click', () => {
        populateVisibleButtonsModal();
        visibleButtonsModal.style.display = 'block';
    });

    visibleButtonsModal.querySelector('.close').addEventListener('click', () => {
        visibleButtonsModal.style.display = 'none';
    });

        function updateBottomBar() {
            const infoDiv = document.getElementById('bottom-bar-info');
            if (buttonsForRemoval.size === 1) {
                const buttonId = buttonsForRemoval.values().next().value;
                const projectData = loadProjectData(directoryName);
                let customButtonTree = projectData.customButtonTree;

                function findButtonPath(nodes, id, currentPath = []) {
                    for (const node of nodes) {
                        if (node.type === 'button' && String(node.id) === String(id)) {
                            return { button: node, path: currentPath };
                        }
                        if (node.type === 'category' && node.children) {
                            const result = findButtonPath(node.children, id, [...currentPath, node.name]);
                            if (result) {
                                return result;
                            }
                        }
                    }
                    return null;
                }
                
                const result = findButtonPath(customButtonTree, buttonId);

                if (result && result.path.length > 0) {
                    const username = projectUsernameInput.value.trim() || 'username';
                    const category = result.path[0];
                    const fullButtonText = result.button.fullButtonText;
                    infoDiv.textContent = `[${username}]_${category} ${fullButtonText}`;
                } else {
                    infoDiv.textContent = '1 item selected';
                }

            } else if (buttonsForRemoval.size > 1) {
                infoDiv.textContent = `${buttonsForRemoval.size} items selected`;
            } else {
                infoDiv.textContent = '';
            }
        }

        function createSidebarButton(buttonData, path) {
            const { id, name, fullButtonText, specialType } = buttonData;
            
            const button = document.createElement('button');
            button.textContent = name.replace(/[()]/g, ''); // Remove parentheses for display
            button.dataset.id = id;
            const numElements = parseInt(document.getElementById('num-elements-input').value, 10);
            button.style.paddingLeft = `${(numElements) * 8}px`; // Indent based on hierarchy depth

            // Preserve selection state across re-renders
            if (buttonsForRemoval.has(String(id))) {
                button.classList.add('selected-for-removal');
            }

            button.onclick = () => {
                const buttonId = button.dataset.id;
                const isCurrentlySelected = button.classList.contains('selected-for-removal');

                if (isCurrentlySelected) {
                    buttonsForRemoval.delete(buttonId);
                    button.classList.remove('selected-for-removal');
                } else {
                    buttonsForRemoval.add(buttonId);
                    button.classList.add('selected-for-removal');
                }
                updateRemoveButtonState();
                updateBottomBar();
                
                // For '+1' buttons, we highlight differently
                if (specialType === 'plusOne') {
                    highlightMatchingThumbnails(path, '', !isCurrentlySelected, true);
                } else {
                    highlightMatchingThumbnails(path, fullButtonText, !isCurrentlySelected, false);
                }
            };

            const fontSize = document.getElementById('font-size-slider').value;
            button.style.cssText += `
                width: 100%; margin: 0; padding-top: 0; padding-bottom: 0; height: 36px;
                background-color: #1877f2; color: #ffffff; border: 1px solid #444444;
                border-top: none; border-radius: 0; font-size: ${fontSize}px; cursor: pointer;
                box-sizing: border-box; text-align: left; display: block;
            `;
            button.style.textAlign = 'left';
            
            adjustButtonFontSize(button);
            return button;
        }

        function highlightMatchingThumbnails(path, fullButtonText, shouldSelect, isCategoryOnly) {
            const username = projectUsernameInput.value.trim();
            if (!username) return;

            const category = path[0];
            const prefix = `[${username}]_${category}`;

            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas) {
                currentCanvas.thumbnails.forEach(thumb => {
                    const baseFilename = thumb.dataset.fileName.substring(0, thumb.dataset.fileName.lastIndexOf('.'));
                    const filenameWithoutNumber = baseFilename.replace(/\s*\(\d+\)$/, '').trim();
                    
                    let matches = false;
                    if (isCategoryOnly) {
                        // For +1, we want an exact match with the prefix, and nothing after it.
                        matches = filenameWithoutNumber === prefix;
                    } else {
                        // For regular buttons, it must start with the prefix and contain the elements.
                        const expectedFilenamePart = `${prefix} ${fullButtonText}`;
                        matches = filenameWithoutNumber.startsWith(expectedFilenamePart);
                    }

                    if (matches) {
                        if (shouldSelect) {
                            if (!selectedThumbnails.has(thumb)) {
                                thumb.classList.add('selected');
                                selectedThumbnails.add(thumb);
                            }
                        } else {
                            if (selectedThumbnails.has(thumb)) {
                                thumb.classList.remove('selected');
                                selectedThumbnails.delete(thumb);
                            }
                        }
                    }
                });
            }
            updatePlayButtonState();
        }

        function adjustButtonFontSize(button) {
            const fontSize = document.getElementById('font-size-slider').value;
            button.style.fontSize = `${fontSize}px`;
        }

        newFilenameBtn.addEventListener('click', () => {
            filenameBuilderModal.style.display = 'block';
            initializeFilenameBuilder();
        });

        removeBtn.addEventListener('click', () => {
            if (buttonsForRemoval.size === 0) {
                alert('Please select one or more buttons to remove.');
                return;
            }

            if (confirm(`Are you sure you want to remove ${buttonsForRemoval.size} button(s)?`)) {
                const projectData = loadProjectData(directoryName);
                let buttonTree = projectData.customButtonTree;
                
                function removeButtonsFromTree(nodes) {
                    if (!Array.isArray(nodes)) return [];
                    
                    // Filter out leaf buttons that should be removed
                    let filteredNodes = nodes.filter(node => {
                        return !(node.type === 'button' && buttonsForRemoval.has(String(node.id)));
                    });

                    // Recurse into remaining category nodes
                    return filteredNodes.map(node => {
                        if (node.type === 'category' && node.children) {
                            node.children = removeButtonsFromTree(node.children);
                        }
                        return node;
                    // After removing children, a category might become empty. Remove it.
                    }).filter(node => !(node.type === 'category' && (!node.children || node.children.length === 0)));
                }
                
                const newButtonTree = removeButtonsFromTree(buttonTree);
                projectData.customButtonTree = newButtonTree;
                saveProjectData(directoryName, projectData);

                buttonsForRemoval.clear();
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                updateRemoveButtonState();
            }
        });

        filenameBuilderModal.querySelector('.close').addEventListener('click', () => {
            filenameBuilderModal.style.display = 'none';
        });

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            let mouseDownEvent = null;

            element.addEventListener('dragstart', (e) => e.preventDefault());
            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                isDragging = false;
                mouseDownEvent = e;

                pos3 = e.clientX;
                pos4 = e.clientY;

                if (!isLayoutFrozen) {
                    freezeLayout();
                }

                if (selectedThumbnails.has(element)) {
                    selectedThumbnails.forEach(thumb => {
                        thumb.style.zIndex = zIndexCounter++;
                    });
                } else {
                    element.style.zIndex = zIndexCounter++;
                }
                
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                isDragging = true;
                e = e || window.event;
                e.preventDefault();

                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                if (selectedThumbnails.has(element)) {
                    selectedThumbnails.forEach(thumb => {
                        const containerRect = thumbnailContainer.getBoundingClientRect();
                        const elementRect = thumb.getBoundingClientRect();
                        
                        let newTop = thumb.offsetTop - pos2;
                        let newLeft = thumb.offsetLeft - pos1;

                        if (newLeft < 0) newLeft = 0;
                        if (newTop < 0) newTop = 0;
                        
                        thumb.style.top = newTop + "px";
                        thumb.style.left = newLeft + "px";
                    });
                } else {
                    const containerRect = thumbnailContainer.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();
                    
                    let newTop = element.offsetTop - pos2;
                    let newLeft = element.offsetLeft - pos1;

                    if (newLeft < 0) newLeft = 0;
                    if (newTop < 0) newTop = 0;
                    
                    element.style.top = newTop + "px";
                    element.style.left = newLeft + "px";
                }
            }

            function closeDragElement() {
                 if (!isDragging) {
                    const wrapper = element;
                    const clickEvent = mouseDownEvent;
                    if (isMultiSelectMode || clickEvent.ctrlKey || clickEvent.metaKey) {
                        if (selectedThumbnails.has(wrapper)) {
                            wrapper.classList.remove('selected');
                            selectedThumbnails.delete(wrapper);
                        } else {
                            wrapper.classList.add('selected');
                            selectedThumbnails.add(wrapper);
                        }
                    } else {
                        selectedThumbnails.forEach(t => t.classList.remove('selected'));
                        selectedThumbnails.clear();
                        wrapper.classList.add('selected');
                        selectedThumbnails.add(wrapper);
                    }
                    updatePlayButtonState();
                }

                document.onmouseup = null;
                document.onmousemove = null;

                const canvasData = {
                    canvases: Array.from(canvases.values()).map(c => ({
                        id: c.id,
                        name: c.name,
                        thumbnails: c.thumbnails.map(t => ({
                            fileName: t.dataset.fileName,
                            left: t.style.left,
                            top: t.style.top,
                            previousCanvasId: t.dataset.previousCanvasId
                        }))
                    })),
                    activeCanvasId: activeCanvasId
                };
                const projectData = loadProjectData(directoryName);
                projectData.canvases = canvasData;
                saveProjectData(directoryName, projectData);
                updateContentSpacer();
            }
        }

        function freezeLayout() {
            const wrappers = thumbnailContainer.querySelectorAll('.thumbnail-wrapper');
            if (wrappers.length === 0) return;

            const positions = [];
            wrappers.forEach(wrapper => {
                positions.push({
                    left: wrapper.offsetLeft,
                    top: wrapper.offsetTop
                });
            });

            wrappers.forEach((wrapper, index) => {
                wrapper.style.position = 'absolute';
                wrapper.style.left = positions[index].left + 'px';
                wrapper.style.top = positions[index].top + 'px';
            });
            
            isLayoutFrozen = true;
            updateContentSpacer();
        }

        function sortThumbnails(sortBy) {
            const canvas = canvases.get(activeCanvasId);
            if (!canvas) return;

            isLayoutFrozen = false; 
            
            if (sortBy === 'name') {
                canvas.thumbnails.sort((a, b) => a.dataset.fileName.localeCompare(b.dataset.fileName));
            } else if (sortBy === 'random') {
                canvas.thumbnails.sort(() => Math.random() - 0.5);
            }

            renderCanvas(activeCanvasId);
        }

        function saveLayout() {
            const layoutName = layoutNameInput.value.trim();
            if (!layoutName) {
                alert('Please enter a name for the layout.');
                layoutNameInput.focus();
                return;
            }
            if (!isLayoutFrozen) {
                alert('Please move at least one thumbnail before saving the layout.');
                return;
            }

            const thumbnails = document.querySelectorAll('.thumbnail');
            const layoutData = {
                positions: {},
                size: sizeSelector.value
            };
            thumbnails.forEach(thumb => {
                layoutData.positions[thumb.dataset.fileName] = {
                    left: thumb.style.left,
                    top: thumb.style.top
                };
            });
            
            const projectData = loadProjectData(directoryName);
            projectData.layouts[layoutName] = layoutData;
            saveProjectData(directoryName, projectData);
            
            layoutNameInput.value = '';
            populateLayoutsDropdown();
            alert(`Layout "${layoutName}" saved!`);
        }

        layoutNameInput.addEventListener('input', () => {
            if (layoutNameInput.value.trim() !== '') {
                saveLayoutBtn.textContent = 'Save Layout';
            }
        });

        function loadLayout() {
            const selectedValue = layoutSelect.value;
            if (!selectedValue) return;

            if (selectedValue.startsWith('scan_')) {
                const layoutName = selectedValue.replace('scan_', '');
                const layoutData = scanLayouts[layoutName];
                if (layoutData) {
                    applyScanLayout(layoutData);
                }
                return;
            }

            const projectData = loadProjectData(directoryName);
            const layoutData = projectData.layouts[selectedValue];
            
            if (!layoutData) return;

            if (!isLayoutFrozen) {
                freezeLayout();
            }
            
            sizeSelector.value = layoutData.size;
            applyThumbnailSize();

            const thumbnails = document.querySelectorAll('.thumbnail');
            thumbnails.forEach(thumb => {
                const pos = layoutData.positions[thumb.dataset.fileName];
                if (pos) {
                    thumb.style.left = pos.left;
                    thumb.style.top = pos.top;
                }
            });
            updateContentSpacer();
        }

        function deleteLayout() {
            const layoutName = layoutSelect.value;
            if (!layoutName) {
                alert('Please select a layout to delete.');
                return;
            }
            if (confirm(`Are you sure you want to delete the "${layoutName}" layout?`)) {
                const projectData = loadProjectData(directoryName);
                delete projectData.layouts[layoutName];
                saveProjectData(directoryName, projectData);
                populateLayoutsDropdown();
            }
        }

        function applyScanLayout(layoutData) {
            if (!isLayoutFrozen) {
                freezeLayout();
            }

            const allThumbs = Array.from(document.querySelectorAll('.thumbnail'));
            const thumbMap = new Map(allThumbs.map(t => [t.dataset.fileName, t]));
            const groupedThumbs = new Set();
            let currentY = 0;

            // Sort groups by header name
            layoutData.sort((a, b) => a.Header.localeCompare(b.Header));

            layoutData.forEach(group => {
                if (group.IsGroup) {
                    let currentX = 0;
                    let maxRowHeight = 0;

                    group.AllChildren.forEach(child => {
                        const pathParts = child.Item.ItemInfo.Path.split('\\');
                        const videoFilename = pathParts[pathParts.length - 1];
                        const thumbFilename = videoFilename.substring(0, videoFilename.lastIndexOf('.')) + '.jpg';
                        
                        const thumb = thumbMap.get(thumbFilename);
                        if (thumb) {
                            if (currentX + thumb.offsetWidth > thumbnailContainer.clientWidth) {
                                currentX = 0;
                                currentY += maxRowHeight + 20; // 20px vertical gap
                                maxRowHeight = 0;
                            }
                            thumb.style.left = currentX + 'px';
                            thumb.style.top = currentY + 'px';
                            currentX += thumb.offsetWidth + 20; // 20px horizontal gap
                            if (thumb.offsetHeight > maxRowHeight) {
                                maxRowHeight = thumb.offsetHeight;
                            }
                            groupedThumbs.add(thumb);
                        }
                    });
                     if (group.AllChildren.length > 0) {
                        currentY += maxRowHeight + (thumbMap.values().next().value?.offsetHeight || 200);
                    }
                }
            });

            // Handle ungrouped thumbnails
            let currentX = 0;
            let maxRowHeight = 0;
            allThumbs.forEach(thumb => {
                if (!groupedThumbs.has(thumb)) {
                    if (currentX + thumb.offsetWidth > thumbnailContainer.clientWidth) {
                        currentX = 0;
                        currentY += maxRowHeight + 20;
                        maxRowHeight = 0;
                    }
                    thumb.style.left = currentX + 'px';
                    thumb.style.top = currentY + 'px';
                    currentX += thumb.offsetWidth + 20;
                    if (thumb.offsetHeight > maxRowHeight) {
                        maxRowHeight = thumb.offsetHeight;
                    }
                }
            });

            updateContentSpacer();
        }

        function populateLayoutsDropdown() {
            const projectData = loadProjectData(directoryName);
            const savedLayoutNames = Object.keys(projectData.layouts);
            const scanLayoutNames = Object.keys(scanLayouts);

            layoutSelect.innerHTML = '<option value="" disabled hidden>Select Layout</option>';

            if (scanLayoutNames.length > 0) {
                const scanGroup = document.createElement('optgroup');
                scanGroup.label = 'Scan Layouts';
                scanLayoutNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = `scan_${name}`;
                    option.textContent = name;
                    scanGroup.appendChild(option);
                });
                layoutSelect.appendChild(scanGroup);
            }

            if (savedLayoutNames.length > 0) {
                const savedGroup = document.createElement('optgroup');
                savedGroup.label = 'Saved Layouts';
                savedLayoutNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    savedGroup.appendChild(option);
                });
                layoutSelect.appendChild(savedGroup);
            }
        }

        function startSelection(e) {
            if (e.target !== thumbnailContainer) return;
            e.preventDefault();

            const containerRect = thumbnailContainer.getBoundingClientRect();
            let startX = e.clientX - containerRect.left + thumbnailContainer.scrollLeft;
            let startY = e.clientY - containerRect.top + thumbnailContainer.scrollTop;

            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';

            document.addEventListener('mousemove', handleSelection);
            document.addEventListener('mouseup', endSelection);

            function handleSelection(e) {
                let currentX = e.clientX - containerRect.left + thumbnailContainer.scrollLeft;
                let currentY = e.clientY - containerRect.top + thumbnailContainer.scrollTop;

                let newLeft = Math.min(startX, currentX);
                let newTop = Math.min(startY, currentY);
                let newWidth = Math.abs(startX - currentX);
                let newHeight = Math.abs(startY - currentY);

                selectionBox.style.left = newLeft + 'px';
                selectionBox.style.top = newTop + 'px';
                selectionBox.style.width = newWidth + 'px';
                selectionBox.style.height = newHeight + 'px';
            }

            function endSelection(e) {
                document.removeEventListener('mousemove', handleSelection);
                document.removeEventListener('mouseup', endSelection);
                
                selectThumbnailsInBox();
                selectionBox.style.display = 'none';
            }
        }

        function selectThumbnailsInBox() {
            const boxRect = selectionBox.getBoundingClientRect();
            const wrappers = document.querySelectorAll('.thumbnail-wrapper');

            if (!isMultiSelectMode) {
                selectedThumbnails.forEach(t => t.classList.remove('selected'));
                selectedThumbnails.clear();
            }
            
            wrappers.forEach(wrapper => {
                const wrapperRect = wrapper.getBoundingClientRect();
                
                if (
                    boxRect.left < wrapperRect.right &&
                    boxRect.right > wrapperRect.left &&
                    boxRect.top < wrapperRect.bottom &&
                    boxRect.bottom > wrapperRect.top
                ) {
                    if (!selectedThumbnails.has(wrapper)) {
                       wrapper.classList.add('selected');
                       selectedThumbnails.add(wrapper);
                    }
                }
            });
            updatePlayButtonState();
        }

        const resizer = document.getElementById('sidebar-resizer');
        const sidebar = document.getElementById('sidebar');

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();

            const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                // Adjust font size for all buttons after resizing
                const buttons = document.querySelectorAll('#sidebar-scroll-container button');
                buttons.forEach(button => adjustButtonFontSize(button));
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });

        function handleMouseMove(e) {
            const newWidth = e.clientX;
            if (newWidth > 100 && newWidth < 500) { // Min and max width
                sidebar.style.width = newWidth + 'px';
            }
        }

        generateEditThumbnailsNewBtn.addEventListener('click', () => {
            const trackingFileName = 'processed_edit_mode_videos.txt';
            const script = [
                '@echo off',
                'setlocal enabledelayedexpansion',
                'cd /d "%~dp0"',
                'echo Generating edit thumbnails for new files...',
                'if not exist "Edit Thumbnails" mkdir "Edit Thumbnails"',
                `set "trackingFile=${trackingFileName}"`,
                'if not exist "!trackingFile!" ( echo. > "!trackingFile!" )',
                '',
                'for %%F in (*.mp4, *.avi, *.mov, *.mkv) do (',
                '    set "videoFile=%%F"',
                '    findstr /x /c:"!videoFile!" "!trackingFile!" >nul',
                '    if errorlevel 1 (',
                '        echo Processing new file: !videoFile!',
                '        set "baseName=%%~nF"',
                `        for /f "delims=" %%a in ('ffprobe -v error -show_entries format^=duration -of default^=noprint_wrappers^=1:nokey^=1 "!videoFile!"') do (`,
                '            set "duration_str=%%a"',
                '        )',
                '        for /f "delims=." %%a in ("!duration_str!") do set "duration_int=%%a"',
                '        if !duration_int! equ 0 set "duration_int=10"',
                '        set /a "interval = !duration_int! / 10"',
                '        if !interval! equ 0 set "interval=1"',
                '        for /l %%i in (1, 1, 10) do (',
                '            set /a "timestamp = (%%i - 1) * !interval!"',
                `            ffmpeg -ss !timestamp! -i "!videoFile!" -vframes 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" -y "Edit Thumbnails\\!baseName!_%%i.jpg" >nul 2>&1`,
                '            if errorlevel 1 (',
                '                echo Failed to generate thumbnail %%i for !videoFile!',
                '            )',
                '        )',
                '        echo !videoFile!>> "!trackingFile!"',
                '    )',
                ')',
                '',
                'echo Thumbnail generation for new files complete.',
                'pause'
            ].join('\r\n');

            editScriptModal.querySelector('h2').textContent = 'Generate Thumbnails for Edit Mode for New Files';
            document.getElementById('edit-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-edit-script-link').href = URL.createObjectURL(blob);
            document.getElementById('download-edit-script-link').download = 'generate_edit_thumbnails_new.bat';
            editScriptModal.style.display = 'block';
        });

        generateFolderThumbnailsBtn.addEventListener('click', () => {
            const script = [
                '@echo off',
                'echo This will delete and regenerate all thumbnails in the Thumbnails folder.',
                'pause',
                'if exist "Thumbnails" ( rmdir /S /Q "Thumbnails" )',
                'mkdir "Thumbnails"',
                ...allVideoFiles.map(file => {
                    const fileName = file.name;
                    const thumbnailName = fileName.substring(0, fileName.lastIndexOf('.')) + '.jpg';
                    return `ffmpeg -y -i "${fileName}" -ss 00:00:02.000 -frames:v 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" "Thumbnails\\${thumbnailName}" >nul 2>&1 || echo Failed to generate thumbnail for ${fileName}`;
                }),
                'echo.',
                'echo Thumbnail regeneration complete.',
                'pause'
            ].join('\r\n');
            
            batchScriptTextArea.value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
            downloadScriptLink.download = 'generate_folder_thumbnails.bat';
            scriptModal.style.display = 'block';
        });

        refreshThumbnailsBtn.addEventListener('click', () => {
            const script = [
                '@echo off',
                'setlocal enabledelayedexpansion',
                'cd /d "%~dp0"',
                'echo Refreshing thumbnails...',
                'set "videoFiles=video_files.tmp"',
                '> "!videoFiles!" (',
                ...allVideoFiles.map(file => `    echo ${file.name.substring(0, file.name.lastIndexOf('.'))}`),
                ')',
                '',
                'for %%f in ("Thumbnails\\*.jpg") do (',
                '    set "thumbName=%%~nf"',
                '    findstr /x /c:"!thumbName!" "!videoFiles!" >nul',
                '    if errorlevel 1 (',
                '        echo Deleting orphaned thumbnail: %%f',
                '        del "%%f"',
                '    )',
                ')',
                '',
                'del "!videoFiles!"',
                '',
                ...allVideoFiles.map(file => {
                    const fileName = file.name;
                    const thumbnailName = fileName.substring(0, fileName.lastIndexOf('.')) + '.jpg';
                    return `if not exist "Thumbnails\\${thumbnailName}" ( ffmpeg -y -i "${fileName}" -ss 00:00:02.000 -frames:v 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" "Thumbnails\\${thumbnailName}" >nul 2>&1 || echo Failed to generate thumbnail for ${fileName} )`;
                }),
                'echo.',
                'echo Thumbnail refresh complete.',
                'pause'
            ].join('\r\n');

            batchScriptTextArea.value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
            downloadScriptLink.download = 'refresh_thumbnails.bat';
            scriptModal.style.display = 'block';
        });

        document.getElementById('export-project-btn').addEventListener('click', () => {
            if (!directoryName) {
                alert('Please load a directory first.');
                return;
            }
            const projectData = loadProjectData(directoryName);
            const dataStr = JSON.stringify(projectData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${directoryName}-project.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('import-project-btn').addEventListener('click', () => {
            if (!directoryName) {
                alert('Please load a directory first.');
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    try {
                        const projectData = JSON.parse(readerEvent.target.result);
                        // We can add more validation here, e.g., checking version
                        saveProjectData(directoryName, projectData);
                        alert('Project data imported successfully! Reloading...');
                        location.reload();
                    } catch (err) {
                        alert('Failed to parse project file.');
                    }
                }
                reader.readAsText(file);
            }
            input.click();
        });
    </script>
</body>
</html>
